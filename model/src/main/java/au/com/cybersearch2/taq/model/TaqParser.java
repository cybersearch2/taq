/* Generated By:JavaCC: Do not edit this line. TaqParser.java */
package au.com.cybersearch2.taq.model;

/** Copyright 2022 Andrew J Bowley

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. */

import java.io.InputStream;
import java.util.List;
import java.util.ArrayList;

import au.com.cybersearch2.taq.language.BooleanTerm;
import au.com.cybersearch2.taq.language.DoubleTerm;
import au.com.cybersearch2.taq.language.DualIndex;
import au.com.cybersearch2.taq.language.ExpressionIndex;
import au.com.cybersearch2.taq.language.Group;
import au.com.cybersearch2.taq.language.IOperand;
import au.com.cybersearch2.taq.language.IVariableSpec;
import au.com.cybersearch2.taq.language.IntegerTerm;
import au.com.cybersearch2.taq.language.KeyName;
import au.com.cybersearch2.taq.language.ListReference;
import au.com.cybersearch2.taq.language.LiteralParameter;
import au.com.cybersearch2.taq.language.LiteralType;
import au.com.cybersearch2.taq.language.QualifiedName;
import au.com.cybersearch2.taq.language.QuerySpec;
import au.com.cybersearch2.taq.language.StringTerm;
import au.com.cybersearch2.taq.language.TextDecoder;
import au.com.cybersearch2.taq.language.Unknown;
import au.com.cybersearch2.taq.language.TaqLiteral;
import au.com.cybersearch2.taq.language.Term;
import au.com.cybersearch2.taq.language.IOperand;
import au.com.cybersearch2.taq.language.ITemplate;
import au.com.cybersearch2.taq.language.OperandType;
import au.com.cybersearch2.taq.language.Parameter;
import au.com.cybersearch2.taq.language.InitialProperties;
import au.com.cybersearch2.taq.engine.Compiler;
import au.com.cybersearch2.taq.language.SyntaxException;
import au.com.cybersearch2.taq.engine.Extent;
import au.com.cybersearch2.taq.engine.Parser;
import au.com.cybersearch2.taq.engine.SourceItem;
import au.com.cybersearch2.taq.engine.SourceMarker;
import au.com.cybersearch2.taq.engine.SourceTracker;
import au.com.cybersearch2.taq.engine.Unit;
import au.com.cybersearch2.taq.artifact.NameIndex;
import au.com.cybersearch2.taq.artifact.NestedFlowArtifact;
import au.com.cybersearch2.taq.artifact.ArchetypeArtifact;
import au.com.cybersearch2.taq.artifact.TemplateArtifact;
import au.com.cybersearch2.taq.artifact.FunctionArtifact;
import au.com.cybersearch2.taq.artifact.ResourceArtifact;
import au.com.cybersearch2.taq.artifact.ListArtifact;
import au.com.cybersearch2.taq.artifact.ChoiceArtifact;
import au.com.cybersearch2.taq.artifact.TermArtifact;


@SuppressWarnings("all")
public class TaqParser implements TaqParserConstants {
  /** Source item start token */
  private Token itemToken;
  private boolean sentinalPending = false;
  private String currentName = "";
  private String currentNonTerminal = SourceTracker.INPUT;

  public Parser publish() {
        return new Parser() {

            @Override
            public void parse(Compiler compiler) {
                  try
                  {
                          input(compiler);
                  } catch (ParseException e) {
                      throw new SyntaxException("eXPL compile failed", e);
                  }
                }

            @Override
            public void reinitialize(InputStream inputStream) {
                ReInit(inputStream);
            }

            @Override
            public Parser parserInstance(InputStream instream) {
            return new TaqParser(instream).publish();
            }
         };
  }

   /**
   * Returns content of string literal token stipped of quote delimiters
   * @param stringLiteral Token object
   * @return String
   */
  private String getText(Token stringLiteral) {
     String text = stringLiteral.image.substring(1, stringLiteral.image.length() - 1);
     if (text.indexOf('/') == -1)
       return text;
     else
       return TextDecoder.decodeString(text).toString();
  }

  private String display(Object value) {
     if (value instanceof String)
       return "\u005c"" + value.toString() + "\u005c"";
     else
       return value.toString();
  }

  private Unit unit(Token token) {
    TaqLiteral literal = literal(token.kind);
    return new Unit(token.beginLine, token.beginColumn, literal);
  }

  private Extent extent(Token token) {
    return new Extent(token.endLine, token.endColumn);
  }

  private void resetItemToken() {
    itemToken = null;
  }

  private void intercept(Token token, Compiler compiler) {
    if (itemToken == null) {
      itemToken = token;
      if (sentinalPending) {
        sentinalPending = false;
        compiler.addSourceItem("", unit(token), extent(token));
      }
    }
  }

  private  void setSentinal() {
    sentinalPending = true;
    resetItemToken();
  }

  private TaqLiteral literal(int kind) {
    switch(kind)
    {
    case TaqParserConstants.AXIOM:
        return TaqLiteral.axiom;

    case TaqParserConstants.BOOLEAN:
        return TaqLiteral.taq_boolean;

    case TaqParserConstants.COMPLEX:
        return TaqLiteral.complex;

    case TaqParserConstants.CURRENCY:
        return TaqLiteral.currency;

    case TaqParserConstants.CURSOR:
        return TaqLiteral.cursor;

    case TaqParserConstants.DECIMAL:
        return TaqLiteral.decimal;

    case TaqParserConstants.DOUBLE:
        return TaqLiteral.taq_double;

    case TaqParserConstants.EXPORT:
        return TaqLiteral.export;

    case TaqParserConstants.FACT:
        return TaqLiteral.fact;

    case TaqParserConstants.FLOW:
        return TaqLiteral.flow;

    case TaqParserConstants.FUNCTION:
        return TaqLiteral.function;

    case TaqParserConstants.IDENTIFIER:
        return TaqLiteral.variable;

    case TaqParserConstants.INCLUDE:
        return TaqLiteral.include;

    case TaqParserConstants.INTEGER:
        return TaqLiteral.integer;

    case TaqParserConstants.LIST:
        return TaqLiteral.list;

    case TaqParserConstants.MAP:
        return TaqLiteral.map;

    case TaqParserConstants.PATTERN:
        return TaqLiteral.pattern;

    case TaqParserConstants.QUERY:
        return TaqLiteral.query;

    case TaqParserConstants.RESOURCE:
        return TaqLiteral.resource;

    case TaqParserConstants.REVERSE:
        return TaqLiteral.reverse;

    case TaqParserConstants.SCOPE:
        return TaqLiteral.scope;

    case TaqParserConstants.SELECT:
        return TaqLiteral.select;

    case TaqParserConstants.STRING:
        return TaqLiteral.string;

    case TaqParserConstants.TEMPLATE:
        return TaqLiteral.template;

    case TaqParserConstants.TERM:
        return TaqLiteral.term;

    case TaqParserConstants.UNKNOWN:
        return TaqLiteral.unknown;

    default:
    }
    return TaqLiteral.post_release;
  }

/** Root production. */
  final public void input(Compiler compiler) throws ParseException
 {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 91:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      if (jj_2_1(2)) {
        ContextDeclaration(compiler);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 91:
          ArchetypeDeclaration(compiler);
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      currentNonTerminal = SourceTracker.INPUT;
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AXIOM:
      case BOOLEAN:
      case COMPLEX:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case EXPORT:
      case FLOW:
      case INCLUDE:
      case INTEGER:
      case LIST:
      case PATTERN:
      case QUERY:
      case RESOURCE:
      case SCOPE:
      case SELECT:
      case STRING:
      case TEMPLATE:
      case TERM:
      case IDENTIFIER:
      case AT:
      case SLASH:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AXIOM:
      case BOOLEAN:
      case COMPLEX:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case EXPORT:
      case FLOW:
      case INCLUDE:
      case INTEGER:
      case LIST:
      case SELECT:
      case STRING:
      case TEMPLATE:
      case TERM:
      case IDENTIFIER:
      case AT:
      case SLASH:
        Statement(compiler);
        break;
      case QUERY:
        QueryChain(compiler);
        break;
      case SCOPE:
        ScopeDeclaration(compiler);
        break;
      case PATTERN:
        PatternDeclaration(compiler);
        break;
      case RESOURCE:
        ResourceDeclaration(compiler);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        currentNonTerminal = SourceTracker.INPUT;
    }
    jj_consume_token(0);

  }

  final public void ContextDeclaration(Compiler compiler) throws ParseException
 {
  Token listToken;
  Token nameToken;
  Token scopeToken;
  IVariableSpec varSpec;
    scopeToken = jj_consume_token(91);
    listToken = jj_consume_token(LIST);
    varSpec = ListType(compiler);
    nameToken = jj_consume_token(IDENTIFIER);
    StringBuilder builder = new StringBuilder();
    builder.append(scopeToken.image).append(' ');
    builder.append(listToken.image);
    builder.append(varSpec.getSource());
    builder.append(' ').append(nameToken.image);
    compiler.addSourceItem(builder.toString(), unit(scopeToken), extent(token));
    compiler.getListFactoryArtifact().contextListDeclaration(nameToken.image, varSpec);
  }

  final public void ArchetypeDeclaration(Compiler compiler) throws ParseException
 {
  Token templateToken;
  Token scopeToken;
  Token axiomToken = null;
  ArchetypeArtifact parserArchetype;
  StringBuilder builder = new StringBuilder();
    scopeToken = jj_consume_token(91);
    templateToken = jj_consume_token(TEMPLATE);
    jj_consume_token(LT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AXIOM:
      axiomToken = jj_consume_token(AXIOM);
      break;
    case TERM:
      jj_consume_token(TERM);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    boolean isList = axiomToken != null;
    builder.append(scopeToken.image).append(' ');
    builder.append(templateToken.image);
    builder.append('<').append(isList ? "axiom" : "term").append('>');
    compiler.addSourceItem(builder.toString(), unit(scopeToken), extent(token));
    isList = axiomToken != null;
    parserArchetype = Archetype(isList, compiler);
    Terms(parserArchetype, compiler);
  }

  final public ArchetypeArtifact Archetype(boolean isList, Compiler compiler) throws ParseException
 {
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    compiler.appendSourceItem(extent(token), " " + nameToken.image);
    ArchetypeArtifact parserArchetype = compiler.archetypeArtifactInstance(nameToken.image, isList);
    {if (true) return parserArchetype;}
    throw new Error("Missing return statement in function");
  }

  final public void Terms(ArchetypeArtifact parserArchetype, Compiler compiler) throws ParseException
 {
  Token encloseToken;
  String termName;
  IVariableSpec varSpec;
  StringBuilder builder = new StringBuilder();
    encloseToken = jj_consume_token(LPAREN);
                     intercept(encloseToken, compiler);
    builder.append('(');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
      varSpec = Type(compiler);
      termName = TermName(parserArchetype.getQualifiedAxiomName(), compiler);
      builder.append(varSpec.getSource()).append(' ').append(termName);
      parserArchetype.addTerm(varSpec, termName);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        varSpec = Type(compiler);
        termName = TermName(parserArchetype.getQualifiedAxiomName(), compiler);
        builder.append(varSpec.getSource()).append(' ').append(termName);
        parserArchetype.addTerm(varSpec, termName);
      }
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    builder.append(')');
    compiler.appendSourceItem(extent(token), " " + builder.toString());
  }

  final public void ResourceDeclaration(Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token resourceToken = null;
  Token listToken = null;
  Token axiomToken = null;
  Token templateToken = null;
  Token nameToken;
  String termHeader = null;
  String emitterClass = null;
  String collectorClass = null;
  QualifiedName qualifiedAxiomName;
  QualifiedName qualifiedTemplateName;
  QualifiedName qualifiedListName;
  ResourceArtifact parserResource;
  FunctionArtifact parserFunction = null;
  InitialProperties properties;
  currentNonTerminal = "ResourceDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
    resourceToken = jj_consume_token(RESOURCE);
    nameToken = jj_consume_token(IDENTIFIER);
    compiler.addSourceItem(resourceToken.image + " " + nameToken.image, unit(resourceToken), extent(token));
    parserResource = compiler.resourceArtifactInstance(nameToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case COLON:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        ResourceSignature(parserResource, compiler);
        break;
      case LPAREN:
        InitialiserList(properties = new InitialProperties(), compiler);
        parserResource.setProperties(properties);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(LBRACE);
    compiler.appendSourceItem(extent(token), delimitToken.image);
    if (jj_2_2(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        collectorClass = CollectorClass(compiler);
        parserResource.setCollectorClass(collectorClass);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      axiomToken = jj_consume_token(AXIOM);
      qualifiedAxiomName = AxiomKeyName(compiler);
      termHeader = TermHeader(qualifiedAxiomName, true, false, compiler);
      compiler.addSourceItem("axiom" + termHeader, unit(axiomToken), extent(token));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RARROW:
        emitterClass = EmitterClass(compiler);
        parserResource.setEmitterClass(emitterClass);
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
     if (emitterClass == null) {
       parserResource.setCollectorAxiomName(qualifiedAxiomName);
       parserResource.setHasCollectorAxiom(true);
     } else {
       parserResource.setEmitterAxiomName(qualifiedAxiomName);
       parserResource.setHasEmitterAxiom(true);
     }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AXIOM:
    case LIST:
    case TEMPLATE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
        templateToken = jj_consume_token(TEMPLATE);
        qualifiedTemplateName = TemplateName(compiler);
        compiler.addSourceItem(templateToken.image + " " + currentName, unit(templateToken), extent(token));
        parserResource.setQualifiedTemplateName(qualifiedTemplateName);
        parserResource.setHasTemplate(true);
        break;
      case LIST:
        listToken = jj_consume_token(LIST);
        qualifiedListName = Name(compiler, true, false);
        compiler.addSourceItem(listToken.image + " " + currentName, unit(listToken), extent(token));
        parserResource.setQualifiedListName(qualifiedListName);
        parserResource.setHasList(true);
        break;
      case AXIOM:
        axiomToken = jj_consume_token(AXIOM);
        qualifiedAxiomName = AxiomKeyName(compiler);
        termHeader = TermHeader(qualifiedAxiomName, true, false, compiler);
        compiler.addSourceItem("axiom" + termHeader, unit(axiomToken), extent(token));
        parserResource.setEmitterAxiomName(qualifiedAxiomName);
        parserResource.setHasEmitterAxiom(true);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RARROW:
        emitterClass = EmitterClass(compiler);
        parserResource.setEmitterClass(emitterClass);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(RBRACE);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    parserResource.resourceDeclaration();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      delimitToken = jj_consume_token(LPAREN);
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      parserFunction = compiler.functionArtifactInstance(parserResource.getQualifiedName(), nameToken.image);
      Receiver(parserFunction, compiler);
      delimitToken = jj_consume_token(RPAREN);
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      parserResource.resourceBody(parserFunction.getReceiver());
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

  final public String CollectorClass(Compiler compiler) throws ParseException
 {
  Token chainToken;
  Token classnameToken;
    classnameToken = jj_consume_token(STRING_LITERAL);
    chainToken = jj_consume_token(RARROW);
    compiler.appendSourceItem(extent(chainToken), classnameToken.image + " " + chainToken.image);
    {if (true) return getText(classnameToken);}
    throw new Error("Missing return statement in function");
  }

  final public String EmitterClass(Compiler compiler) throws ParseException
 {
  Token chainToken;
  Token classnameToken;
    chainToken = jj_consume_token(RARROW);
    classnameToken = jj_consume_token(STRING_LITERAL);
    compiler.appendSourceItem(extent(classnameToken), chainToken.image+ " " + classnameToken.image);
    {if (true) return getText(classnameToken);}
    throw new Error("Missing return statement in function");
  }

  final public void ResourceSignature(ResourceArtifact parserResource, Compiler compiler) throws ParseException
 {
  Token referenceToken;
  InitialProperties properties = new InitialProperties();
    referenceToken = jj_consume_token(STRING_LITERAL);
    compiler.appendSourceItem(extent(referenceToken), " " + referenceToken.image);
    parserResource.setSystemName(getText(referenceToken));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      InitialiserList(properties, compiler);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    parserResource.setProperties(properties);
  }

  final public void Statement(Compiler compiler) throws ParseException
 {
  resetItemToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCLUDE:
      Include(compiler);
      break;
    case AXIOM:
    case EXPORT:
    case LIST:
      ItemDeclaration(compiler);
      break;
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
    case TERM:
      VariableDeclaration(compiler);
      break;
    case TEMPLATE:
      TemplateDeclaration(compiler);
      break;
    case FLOW:
      FlowDeclaration(compiler);
      break;
    case SELECT:
      SelectDeclaration(compiler);
      break;
    case IDENTIFIER:
    case AT:
    case SLASH:
      ListItemAssign(compiler);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ItemDeclaration(Compiler compiler) throws ParseException
 {
    if (jj_2_3(2)) {
      AxiomDeclaration(compiler);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPORT:
      case LIST:
        ListDeclaration(compiler);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void QueryChain(Compiler compiler) throws ParseException
 {
  QuerySpec querySpec;
  Token queryToken;
  Token chainToken;
  Token typeToken = null;
  compiler.setSourceMarker("QueryChain");
    queryToken = jj_consume_token(QUERY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AXIOM:
        typeToken = jj_consume_token(AXIOM);
        break;
      case TERM:
        typeToken = jj_consume_token(TERM);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(GT);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    querySpec = Query(compiler);
    StringBuilder builder = new StringBuilder(queryToken.image);
    if (typeToken != null)
      builder.append('<').append(typeToken.image).append('>');
    builder.append(' ').append(querySpec.getName());
    compiler.addSourceItem(builder.toString(), unit(queryToken), extent(token));
    querySpec = QueryDeclaration(querySpec, compiler);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RARROW:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_4;
      }
      chainToken = jj_consume_token(RARROW);
       compiler.appendSourceItem(extent(chainToken), chainToken.image);
      QueryDeclaration(querySpec.chain(), compiler);
    }
    TaqLiteral literal = null;
    if (typeToken != null)
      literal = unit(typeToken).getKind();
    compiler.getQueryArtifact().queryChain(querySpec, literal);
  }

  final public void FunctionDeclaration(Compiler compiler) throws ParseException
 {
  Token functionToken;
  Token nameToken;
  Token listToken = null;
  Token typeToken = null;
  Token archetypeToken = null;
  OperandType operandType = null;
  IVariableSpec varSpec = null;

  String parameterSignature = null;
  compiler.setSourceMarker("Function");
    functionToken = jj_consume_token(FUNCTION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AXIOM:
    case BOOLEAN:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case LIST:
    case STRING:
    case UNKNOWN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case INTEGER:
      case STRING:
        operandType = BasicType(compiler);
        break;
      case LIST:
        listToken = jj_consume_token(LIST);
        varSpec = ListType(compiler);
        operandType = varSpec.getOperandType();
        break;
      case UNKNOWN:
        typeToken = jj_consume_token(UNKNOWN);
                          operandType = OperandType.UNKNOWN;
        break;
      case AXIOM:
        typeToken = jj_consume_token(AXIOM);
        jj_consume_token(LT);
        archetypeToken = jj_consume_token(IDENTIFIER);
        jj_consume_token(GT);
                                                            operandType = OperandType.AXIOM;
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      parameterSignature = ParameterSignature(compiler);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    StringBuilder builder = new StringBuilder();
    if (listToken != null) {
      builder.append(listToken.image);
      builder.append(varSpec.getSource());
    } else if (operandType != null)
      builder.append(operandType.name());
    else if (typeToken != null)
      builder.append(typeToken.image);
    if (operandType == OperandType.AXIOM)
      builder.append('<').append(archetypeToken.image).append('>');
    builder.append(' ').append(functionToken.image).append(' ').append(nameToken.image);
    if (parameterSignature != null)
      builder.append(' ').append(parameterSignature);
    compiler.addSourceItem(builder.toString(), unit(functionToken), extent(token));
    String archetype = archetypeToken != null ? archetypeToken.image : "";
    compiler.getFunctionFactoryArtifact().function(nameToken.image, operandType, listToken != null, archetype);
  }

  final public OperandType BasicType(Compiler compiler) throws ParseException
 {
  Token typeToken;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      typeToken = jj_consume_token(INTEGER);
      break;
    case DOUBLE:
      typeToken = jj_consume_token(DOUBLE);
      break;
    case DECIMAL:
      typeToken = jj_consume_token(DECIMAL);
      break;
    case BOOLEAN:
      typeToken = jj_consume_token(BOOLEAN);
      break;
    case STRING:
      typeToken = jj_consume_token(STRING);
      break;
    case CURRENCY:
      typeToken = jj_consume_token(CURRENCY);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    intercept(typeToken, compiler);
    {if (true) return compiler.getOperandType(unit(typeToken).getKind());}
    throw new Error("Missing return statement in function");
  }

  final public String ParameterSignature(Compiler compiler) throws ParseException
 {
   StringBuilder builder = new StringBuilder();
   String typedParameter;
    jj_consume_token(LPAREN);
             builder.append('(');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
    case TERM:
      typedParameter = TypedParameter(compiler);
                                               builder.append(typedParameter);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        typedParameter = TypedParameter(compiler);
      }
                                                        builder.append(',').append(typedParameter);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QMARK:
    case ELIPSES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QMARK:
        jj_consume_token(QMARK);
          builder.append('?');
        break;
      case ELIPSES:
        jj_consume_token(ELIPSES);
                                               builder.append("...");
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
             builder.append(')');
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TypedParameter(Compiler compiler) throws ParseException
 {
  Token typeToken;
  Token nameToken;
  OperandType operandType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
      operandType = BasicType(compiler);
      break;
    case TERM:
      typeToken = jj_consume_token(TERM);
       intercept(typeToken, compiler);
       operandType=OperandType.TERM;
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    nameToken = jj_consume_token(IDENTIFIER);
     {if (true) return compiler.type(operandType) + " " + nameToken.image;}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec Query(Compiler compiler) throws ParseException
 {
   Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    {if (true) return compiler.getQueryArtifact().createQuerySpec(nameToken.image, true);}
    throw new Error("Missing return statement in function");
  }

  final public QuerySpec QueryDeclaration(QuerySpec querySpec, Compiler compiler) throws ParseException
 {
  KeyName firstKeyname;
  Token delimitToken;
  int keynameCount = 1;
  String source;
  List<Term> termList = new ArrayList<Term>();
    itemToken = jj_consume_token(LPAREN);
    firstKeyname = KeyName(querySpec, true, compiler);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      KeyName(querySpec, false, compiler);
                                                 ++keynameCount;
    }
    delimitToken = jj_consume_token(RPAREN);
           compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      source = TermList(termList, compiler);
             compiler.appendSourceItem(extent(token), source);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
     {if (true) return compiler.getQueryArtifact().queryDeclaration(querySpec, firstKeyname, keynameCount, termList);}
    throw new Error("Missing return statement in function");
  }

  final public KeyName KeyName(QuerySpec querySpec, boolean isFirst, Compiler compiler) throws ParseException
 {
  Token listTeken = null;
  QualifiedName name1 = null;
  QualifiedName name2;
  String source = isFirst ? itemToken.image : "";
  resetItemToken();
    if (jj_2_4(4)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIST:
        listTeken = jj_consume_token(LIST);
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      name1 = AxiomKeyName(compiler);
      jj_consume_token(COLON);
        if (listTeken != null)
          source += listTeken.image + " ";
        source += currentName + ":";
        resetItemToken();
        if (listTeken != null) {
          IOperand listOperand = compiler.getVariableArtifact().getListVariable(name1, false);
          name1 = compiler.getQueryArtifact().wrapList(name1, listOperand);
        }
    } else {
      ;
    }
    name2 = TemplateName(compiler);
                                   source += currentName;
    compiler.addSourceItem(source, unit(itemToken), extent(token));
    {if (true) return compiler.getQueryArtifact().keyName(querySpec, name1, name2);}
    throw new Error("Missing return statement in function");
  }

  final public void PatternDeclaration(Compiler compiler) throws ParseException
 {
  Token patternToken;
  Token nameToken;
  int flags = 0;
  Token regexLit = null;
  Token patternId = null;
  String literal = null;
  String variable = null;
  currentNonTerminal = "PatternDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
    patternToken = jj_consume_token(PATTERN);
    nameToken = jj_consume_token(IDENTIFIER);
     compiler.addSourceItem(patternToken.image + " " + nameToken.image, unit(patternToken),  extent(token));
    if (jj_2_5(2)) {
      flags = RegexFlags(compiler);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      regexLit = jj_consume_token(STRING_LITERAL);
      break;
    case IDENTIFIER:
      patternId = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (regexLit != null)
    {
      compiler.addSourceItem(regexLit.image, unit(regexLit), extent(token));
      literal = getText(regexLit);
    }
    else
    {
      compiler.addSourceItem(patternId.image, unit(patternId), extent(token));
      variable = patternId.image;
    }
    compiler.getRegularExpressionArtifact().patternDeclaration(nameToken.image, literal, variable, flags);
  }

  final public void VariableDeclaration(Compiler compiler) throws ParseException
 {
  Token nameToken;
  Token declareToken = null;
  Token assignToken;
  String name;
  boolean isUntyped = true;
  IVariableSpec varSpec = null;
  IOperand expression = null;
  IOperand operand = null;
  resetItemToken();
  currentNonTerminal = "VariableDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
      varSpec = Type(compiler);
      isUntyped = false;
      break;
    case TERM:
      declareToken = jj_consume_token(TERM);
                          intercept(declareToken, compiler);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    nameToken = jj_consume_token(IDENTIFIER);
    String source = varSpec != null ? varSpec.getSource() : declareToken.image;
    compiler.addSourceItem(source + " " + nameToken.image, unit(itemToken), extent(nameToken));
    name = nameToken.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FACT:
    case ASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
      compiler.appendSourceItem(extent(assignToken), assignToken.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DECIMAL:
        case FACT:
        case SCOPE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case AT:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case SLASH:
        case 93:
          if (jj_2_6(3)) {
            expression = Expression(compiler);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DECIMAL:
            case IDENTIFIER:
            case AT:
            case SLASH:
              expression = Call(compiler);
              break;
            default:
              jj_la1[35] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        case LBRACE:
          operand = LiteralSet(compiler);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case FACT:
        expression = FactTerm(compiler);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    if (operand == null)
      compiler.getVariableArtifact().variableDeclaration(name, expression, isUntyped, varSpec);
    else
      compiler.getComplexArtifact().complexDeclaration(name, operand, varSpec);
  }

  final public QualifiedName AxiomDeclaration(Compiler compiler) throws ParseException
 {
  QualifiedName qualifiedAxiomName;
  Token exportToken = null;
  Token axiomToken = null;
  Token listToken = null;
  currentNonTerminal = "AxiomDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXPORT:
      exportToken = jj_consume_token(EXPORT);
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    axiomToken = jj_consume_token(AXIOM);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      listToken = jj_consume_token(LIST);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    qualifiedAxiomName = AxiomName(compiler);
    Unit unit = unit(axiomToken);
    StringBuilder builder = new StringBuilder(axiomToken.image);
    if (listToken != null)
      builder.append(' ').append(listToken.image);
    builder.append(' ').append(qualifiedAxiomName.toString());
    compiler.addSourceItem(builder.toString(), unit, extent(token));
    AxiomSpecification(qualifiedAxiomName, listToken != null, exportToken != null, compiler);
    {if (true) return qualifiedAxiomName;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand Call(Compiler compiler) throws ParseException
 {
  QualifiedName qname;
  IOperand callOperand;
  FunctionArtifact parserFunction;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case AT:
    case SLASH:
      qname = Name(compiler, false, false);
      break;
    case DECIMAL:
      jj_consume_token(DECIMAL);
      qname = new QualifiedName(TaqLiteral.decimal.name());
      currentName = TaqLiteral.decimal.name();
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    parserFunction = compiler.functionArtifactInstance(qname, currentName);
    callOperand = FunctionCall(parserFunction, compiler);
    {if (true) return callOperand;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand ListVariable(Compiler compiler) throws ParseException
 {
  Token keywordToken;
  Token nameToken;
  Token assignToken = null;
  IVariableSpec varSpec;
  IOperand function = null;
  StringBuilder builder = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      keywordToken = jj_consume_token(LIST);
        builder.append(keywordToken.image);
        intercept(keywordToken, compiler);
      varSpec = ListType(compiler);
      break;
    case AXIOM:
      keywordToken = jj_consume_token(AXIOM);
        builder.append(keywordToken.image);
        varSpec=compiler.getVariableArtifact().termList();
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    nameToken = jj_consume_token(IDENTIFIER);
    builder.append(varSpec.getSource()).append(' ').append(nameToken.image);
    compiler.addSourceItem(builder.toString(), unit(keywordToken), extent(token));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      assignToken = jj_consume_token(ASSIGN);
                      compiler.appendSourceItem(extent(assignToken), " = ");
      function = Call(compiler);
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    {if (true) return compiler.getVariableArtifact().createListVariable(nameToken.image, varSpec, false, false, function);}
    throw new Error("Missing return statement in function");
  }

  final public IOperand CursorVariable(Compiler compiler) throws ParseException
 {
  Token nameToken;
  Token keywordToken = null;
  Token providerToken = null;
  Token directionToken = null;
  Token assignToken = null;
  IVariableSpec varSpec = null;
  IOperand function = null;
  QualifiedName qname;
  QualifiedName target = null;
  FunctionArtifact parserFunction;
  StringBuilder builder = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REVERSE:
      directionToken = jj_consume_token(REVERSE);
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    keywordToken = jj_consume_token(CURSOR);
    if (directionToken != null)
      builder.append(directionToken.image).append(' ');;
    builder.append(keywordToken.image);
    intercept(keywordToken, compiler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      varSpec = ListType(compiler);
      nameToken = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        target = Name(compiler, false, false);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      break;
    case IDENTIFIER:
      nameToken = jj_consume_token(IDENTIFIER);
      jj_consume_token(LPAREN);
      providerToken = jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (varSpec != null) {
      builder.append(varSpec.getSource());
      if (target != null)
        builder.append('(').append(currentName).append(')');
    } else {
      builder.append(nameToken.image).append('(');
      builder.append(providerToken.image).append(')');
    }
    builder.append(' ').append(nameToken.image);
    Token beginToken = directionToken != null ? directionToken : keywordToken;
    compiler.addSourceItem(builder.toString(), unit(beginToken), extent(token));
    if (providerToken != null)
      {if (true) return compiler.getCursorArtifact().createResourceSentinel(nameToken.image, providerToken.image, directionToken != null);}
    else if (target != null)
      {if (true) return compiler.getVariableArtifact().createCursorSentinel(nameToken.image, varSpec, target, directionToken != null);}
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      assignToken = jj_consume_token(ASSIGN);
                      compiler.appendSourceItem(extent(assignToken), " = ");
      qname = Name(compiler, false, false);
      parserFunction = compiler.functionArtifactInstance(qname, currentName);
      function = FunctionCall(parserFunction, compiler);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    {if (true) return compiler.getVariableArtifact().createListVariable(nameToken.image, varSpec, true, directionToken != null, function);}
    throw new Error("Missing return statement in function");
  }

  final public String ListDeclaration(Compiler compiler) throws ParseException
 {
  Token keywordToken;
  Token nameToken;
  Token delimitToken = null;
  Token directionToken = null;
  Token exportToken = null;
  String listName;
  IVariableSpec varSpec = null;
  QualifiedName qualifiedAxiomName = null;
  ITemplate template = null;
  Token beginToken = null;
  Token endToken = null;
  QualifiedName target = null;
  ListArtifact parserList;
  List<String> axiomHeader = null;
  List<ITemplate> axiomList;
  resetItemToken();
  if (currentNonTerminal.equals(SourceTracker.INPUT)) {
    currentNonTerminal = "ListDeclaration";
    compiler.setSourceMarker(currentNonTerminal);
  }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXPORT:
      exportToken = jj_consume_token(EXPORT);
                            intercept(exportToken, compiler);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    keywordToken = jj_consume_token(LIST);
                          intercept(keywordToken, compiler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      varSpec = ListType(compiler);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      delimitToken = jj_consume_token(LBRACKET);
      beginToken = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(COMMA);
      endToken = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    listName = nameToken.image;
    parserList = compiler.listArtifactInstance(listName, varSpec, exportToken != null);
    StringBuilder builder = new StringBuilder();
    if (exportToken != null)
      builder.append(exportToken.image + " " + keywordToken.image);
    else
      builder.append(keywordToken.image);
    if (varSpec != null)
      builder.append(varSpec.getSource());
    builder.append(' ').append(nameToken.image);
    compiler.addSourceItem(builder.toString(), unit(itemToken), extent(token));
    if (beginToken != null)
    {
      compiler.addSourceItem("[" + beginToken.image + "," + endToken.image + "]", unit(delimitToken), extent(token));
      parserList.setRange(Integer.parseInt(beginToken.image), Integer.parseInt(endToken.image));
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case ASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
            resetItemToken();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LIST:
        case IDENTIFIER:
        case AT:
        case SLASH:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LIST:
            keywordToken = jj_consume_token(LIST);
                                  intercept(keywordToken, compiler);
            qualifiedAxiomName = AxiomName(compiler);
              compiler.addSourceItem(keywordToken.image + " " + currentName, unit(keywordToken), extent(token));
              parserList.setQualifiedAxiomName(qualifiedAxiomName);
            break;
          case IDENTIFIER:
          case AT:
          case SLASH:
            target = Name(compiler, false, false);
              compiler.addSourceItem(target.toString(), unit(itemToken), extent(token));
              parserList.setTarget(target);
            break;
          default:
            jj_la1[51] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case REVERSE:
        case LBRACE:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case REVERSE:
            directionToken = jj_consume_token(REVERSE);
            break;
          default:
            jj_la1[52] = jj_gen;
            ;
          }
          template = ListParameters(parserList, compiler);
            if (directionToken != null)
              template.reverse();
            parserList.setTemplate(template);
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LPAREN:
      case LBRACE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          axiomHeader = DynamicTermHeader(compiler);
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
        axiomList = AxiomList(parserList.getQualifiedAxiomName(), parserList.getTermCount(axiomHeader), compiler);
        parserList.setAxiomList(axiomList, axiomHeader);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    parserList.listDeclaration();
    {if (true) return listName;}
    throw new Error("Missing return statement in function");
  }

  final public void CursorDeclaration(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  Token keywordToken;
  Token nameToken;
  Token listToken = null;
  String cursorName;
  Token directionToken = null;
  IVariableSpec varSpec = null;
  if (currentNonTerminal.equals(SourceTracker.INPUT)) {
    currentNonTerminal = "CursorDeclaration";
    compiler.setSourceMarker(currentNonTerminal);
  }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REVERSE:
      directionToken = jj_consume_token(REVERSE);
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    keywordToken = jj_consume_token(CURSOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      varSpec = ListType(compiler);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    cursorName = nameToken.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      listToken = jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    StringBuilder builder = new StringBuilder(keywordToken.image);
    if (varSpec != null)
      builder.append(varSpec.getSource());
    if (listToken != null) {
      builder.append(' ').append(nameToken.image).append('(');
      builder.append(listToken.image).append(')');
    }
    compiler.addSourceItem(builder.toString(), unit(nameToken), extent(token));
    String listName = listToken != null ? listToken.image : cursorName;
    IOperand operand = compiler.getCursorArtifact().cursorDeclaration(varSpec, cursorName, listName, directionToken != null);
    template.addTerm(operand);
  }

  final public void TemplateDeclaration(Compiler compiler) throws ParseException
 {
  TemplateArtifact template;
  currentNonTerminal = "TemplateDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
    itemToken = jj_consume_token(TEMPLATE);
    template = TemplateHead(compiler, false);
    TemplateBody(template, compiler);
    if (template.isReturnsTerm())
       template.createReturnTermList();
  }

  final public void FlowDeclaration(Compiler compiler) throws ParseException
 {
  TemplateArtifact template;
  currentNonTerminal = "FlowDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
    itemToken = jj_consume_token(FLOW);
    template = TemplateHead(compiler, true);
    FlowBody(template, compiler);
    template.flowDeclaration();
  }

  final public void SelectDeclaration(Compiler compiler) throws ParseException
 {
  Token selectToken;
  Token nameToken;
  Token braceToken;
  Token delimitToken;
  String termName;
  int selection = 0;
  ChoiceArtifact parserChoice;
  currentNonTerminal = "SelectDeclaration";
  compiler.setSourceMarker(currentNonTerminal);
  StringBuilder builder;
  QualifiedName mapQname;
    selectToken = jj_consume_token(SELECT);
    nameToken = jj_consume_token(IDENTIFIER);
    String source = selectToken.image + " " + nameToken.image;
    compiler.addSourceItem(source, unit(selectToken), extent(token));
    parserChoice = compiler.choiceArtifactInstance(nameToken.image, false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      delimitToken = jj_consume_token(LPAREN);
      builder = new StringBuilder(delimitToken.image);
      termName = TermName(parserChoice.getQualifiedAxiomName(), compiler);
      builder.append(termName);
      parserChoice.analyseFirstTermName(termName);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[60] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        termName = TermName(parserChoice.getQualifiedAxiomName(), compiler);
        builder.append(',').append(termName);
      }
      jj_consume_token(RPAREN);
      builder.append(')');
      compiler.addSourceItem(builder.toString(), unit(delimitToken), extent(token));
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    braceToken = jj_consume_token(LBRACE);
    compiler.appendSourceItem(extent(braceToken), braceToken.image);
    Selection(selection++, parserChoice, false, compiler);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QMARK:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_8;
      }
      Selection(selection++, parserChoice, false, compiler);
    }
    braceToken = jj_consume_token(RBRACE);
    compiler.appendSourceItem(extent(braceToken), braceToken.image);
  }

  final public TemplateArtifact TemplateHead(Compiler compiler, boolean isCalculator) throws ParseException
 {
  Token nameToken;
  Token termToken = null;
  Token delimitToken = null;
  TemplateArtifact template;
  SourceItem sourceItem;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      jj_consume_token(LT);
      termToken = jj_consume_token(TERM);
      jj_consume_token(GT);
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    boolean returnsTerm = termToken != null;
    StringBuilder builder = new StringBuilder(itemToken.image);
    if (returnsTerm)
      builder.append('<').append(termToken.image).append('.');
    builder.append(' ').append(nameToken.image);
    sourceItem = compiler.addSourceItem(builder.toString(), unit(itemToken), extent(token));
    template = compiler.templateArtifactInstance(nameToken.image, isCalculator, returnsTerm);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      delimitToken = jj_consume_token(LBRACE);
      sourceItem.append(extent(delimitToken), delimitToken.image);
      TemplateScope(template, compiler);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[64] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        TemplateScope(template, compiler);
      }
      delimitToken = jj_consume_token(RBRACE);
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public void TemplateScope(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  Token nameToken;
  Token declareToken = null;
  IVariableSpec varSpec = null;
  resetItemToken();
    if (jj_2_7(2)) {
      ListDeclaration(compiler);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURSOR:
      case REVERSE:
        CursorDeclaration(template, compiler);
        break;
      case SELECT:
        SelectDeclaration(compiler);
        break;
      case BOOLEAN:
      case COMPLEX:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case INTEGER:
      case STRING:
        varSpec = Type(compiler);
        nameToken = jj_consume_token(IDENTIFIER);
      compiler.addSourceItem(varSpec.getSource() + " " + nameToken.image, unit(itemToken), extent(nameToken));
    template.addVariable(varSpec, nameToken.image);
        break;
      case TERM:
        declareToken = jj_consume_token(TERM);
        nameToken = jj_consume_token(IDENTIFIER);
      compiler.addSourceItem(declareToken.image + " " + nameToken.image, unit(declareToken), extent(nameToken));
    compiler.getVariableArtifact().variableDeclaration(nameToken.image, null, true, varSpec);
        break;
      case AXIOM:
      case EXPORT:
        AxiomDeclaration(compiler);
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void TemplateBody(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token privateToken = null;
  IOperand operand;
  currentNonTerminal = "TemplateBody";
  compiler.setSourceMarker(currentNonTerminal);
  template.setOuterTemplateName();
    delimitToken = jj_consume_token(LPAREN);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      privateToken = jj_consume_token(DOT);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    operand = TemplateExpression(template, compiler);
      if (privateToken != null) {
        operand.setPrivate(true);
        privateToken = null;
      }
      template.addTerm(operand);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_10;
      }
      delimitToken = jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
      operand = TemplateExpression(template, compiler);
        if (privateToken != null) {
          operand.setPrivate(true);
          privateToken = null;
        }
        template.addTerm(operand);
    }
    delimitToken = jj_consume_token(RPAREN);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    template.adjustContextName();
  }

  final public void FlowBody(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token privateToken = null;
  IOperand operand;
  List<Term> termList = new ArrayList<Term>();
    delimitToken = jj_consume_token(LPAREN);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      privateToken = jj_consume_token(DOT);
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    operand = Flow(template, compiler);
      if (privateToken != null) {
        operand.setPrivate(true);
        privateToken = null;
      }
      template.addTerm(operand);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_11;
      }
      delimitToken = jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
      operand = Flow(template, compiler);
        if (privateToken != null) {
          operand.setPrivate(true);
          privateToken = null;
        }
        template.addTerm(operand);
    }
    delimitToken = jj_consume_token(RPAREN);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    template.adjustContextName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      TermList(termList, compiler);
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    if (termList.size() > 0)
      template.addProperties(termList);
  }

  final public List<ITemplate> AxiomList(QualifiedName qualifiedAxiomName, int axiomHeaderCount, Compiler compiler) throws ParseException
 {
  List<ITemplate> templateParamList = new ArrayList<ITemplate>();
  ITemplate template;
    template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, axiomHeaderCount, compiler);
    templateParamList.add(template);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_12;
      }
      template = AxiomInitializer(qualifiedAxiomName.getName(), qualifiedAxiomName, axiomHeaderCount, compiler);
     templateParamList.add(template);
    }
    {if (true) return templateParamList;}
    throw new Error("Missing return statement in function");
  }

  final public ITemplate AxiomInitializer(String listName, QualifiedName axiomName, int axiomHeaderCount, Compiler compiler) throws ParseException
 {
  Token braceToken;
  ITemplate initializeTemplate = null;
    itemToken = jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case FACT:
    case INTEGER:
    case LIST:
    case SCOPE:
    case STRING:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case SLASH:
    case 93:
      initializeTemplate = AxiomTerms(listName, axiomHeaderCount, compiler);
      break;
    default:
      jj_la1[75] = jj_gen;
      ;
    }
    braceToken = jj_consume_token(RBRACE);
    if (initializeTemplate != null)
      compiler.appendSourceItem(extent(braceToken), braceToken.image);
    else
      compiler.appendSourceItem(extent(braceToken), itemToken.image + braceToken.image);
    {if (true) return compiler.getAxiomInterface().axiomInitializer(axiomName, initializeTemplate);}
    throw new Error("Missing return statement in function");
  }

  final public ITemplate AxiomTerms(String key, int axiomHeaderCount, Compiler compiler) throws ParseException
 {
  IOperand expression;
  Parameter parameter;
  String functionKey = compiler.functionKey(key);
  ITemplate template = compiler.chainTemplate();
  template.setKey(functionKey);
    if (jj_2_8(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FACT:
      case SCOPE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case SLASH:
      case 93:
        expression = Expression(compiler);
        break;
      case BOOLEAN:
      case COMPLEX:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case INTEGER:
      case STRING:
        expression = TypedLiteralTerm(compiler);
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIST:
        parameter = List(false, compiler);
        expression = (IOperand)parameter;
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      if (axiomHeaderCount > 0) {
        --axiomHeaderCount;
        expression = compiler.termExpression(Term.ANONYMOUS, expression, null);
      }
      template.addTerm(expression);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[78] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      setSentinal();
      if (jj_2_9(3)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FACT:
        case SCOPE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case AT:
        case BANG:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case SLASH:
        case 93:
          expression = Expression(compiler);
          break;
        case BOOLEAN:
        case COMPLEX:
        case CURRENCY:
        case DECIMAL:
        case DOUBLE:
        case INTEGER:
        case STRING:
          expression = TypedLiteralTerm(compiler);
          break;
        default:
          jj_la1[79] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LIST:
          parameter = List(false, compiler);
          expression = (IOperand)parameter;
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
        if (axiomHeaderCount > 0) {
         --axiomHeaderCount;
          expression = compiler.termExpression(Term.ANONYMOUS, expression, null);
        }
        template.addTerm(expression);
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public ITemplate ListParameters(ListArtifact parserList, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  IOperand expression;
  ITemplate template = parserList.chainTemplate();
    delimitToken = jj_consume_token(LBRACE);
    compiler.addSourceItem(delimitToken.image, unit(delimitToken), extent(delimitToken));
    expression = Expression(compiler);
     template.addTerm(parserList.listParameters(expression));
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
      setSentinal();
      expression = Expression(compiler);
      template.addTerm(parserList.listParameters(expression));
    }
    delimitToken = jj_consume_token(RBRACE);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public ITemplate Parameters(String callName, Compiler compiler, boolean nameRequired) throws ParseException
 {
  IOperand expression;
  Parameter parameter;
  String functionKey = compiler.functionKey(callName);
  ITemplate template = compiler.chainTemplate();
  template.setKey(functionKey);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TERM:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case MINUS:
      expression = ParameterExpression(compiler, true);
       template.addTerm(expression);
      break;
    case LIST:
      parameter = List(false, compiler);
      template.addTerm((IOperand)parameter);
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TERM:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case MINUS:
        expression = ParameterExpression(compiler, false);
        template.addTerm(expression);
        break;
      case LIST:
        parameter = List(false, compiler);
       template.addTerm((IOperand)parameter);
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand TemplateExpression(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  Token delimitToken = null;
  Token scopeToken = null;
  Token nameToken = null;
  IOperand operand = null;
  IOperand regexOp = null;
  QualifiedName qname;
  ListReference listReference = null;
  resetItemToken();
    if (jj_2_10(2)) {
      nameToken = jj_consume_token(IDENTIFIER);
       itemToken = nameToken;
       compiler.addSourceItem(nameToken.image, unit(itemToken), extent(token));
      operand = ShortCircuitExpression(nameToken.image, compiler);
    } else if (jj_2_11(2)) {
      operand = TemplateTerm(template.getTemplate(), compiler);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURSOR:
      case REVERSE:
        operand = CursorVariable(compiler);
        break;
      case SCOPE:
        scopeToken = jj_consume_token(SCOPE);
         compiler.addSourceItem(scopeToken.image, unit(scopeToken), extent(scopeToken));
        listReference = IndexExpression(compiler);
         operand = compiler.getScopeArtifact().createScopeTerm(listReference);
        break;
      case AXIOM:
      case LIST:
        operand = ListVariable(compiler);
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand ShortCircuitExpression(String name, Compiler compiler) throws ParseException
 {
  Token rightToken = null;
  Token scToken1 = null;
  Token scToken2 = null;
  Token op = null;
  IOperand expression = null;
    scToken1 = jj_consume_token(QMARK);
                 intercept(scToken1, compiler);
    if (jj_2_12(2)) {
      scToken2 = jj_consume_token(COLON);
    } else {
      ;
    }
    String source = scToken1.image;
    if (scToken2 != null)
      source += scToken2.image;
    else
      scToken2 = scToken1;
     compiler.appendSourceItem(extent(scToken2), " " + source);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      expression = Literals(name, ":".equals(scToken2), compiler);
      {if (true) return expression;}
      break;
    case FACT:
    case SCOPE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case LT:
    case GT:
    case BANG:
    case QMARK:
    case EQ:
    case LE:
    case GE:
    case NE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case SLASH:
    case 93:
      if (jj_2_14(2)) {
        if (jj_2_13(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            rightToken = jj_consume_token(IDENTIFIER);
            break;
          default:
            jj_la1[86] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LT:
            op = jj_consume_token(LT);
            break;
          case GT:
            op = jj_consume_token(GT);
            break;
          case LE:
            op = jj_consume_token(LE);
            break;
          case GE:
            op = jj_consume_token(GE);
            break;
          case EQ:
            op = jj_consume_token(EQ);
            break;
          case NE:
            op = jj_consume_token(NE);
            break;
          case QMARK:
            op = jj_consume_token(QMARK);
            break;
          default:
            jj_la1[87] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          ;
        }
            StringBuilder builder = new StringBuilder();
            if (rightToken != null)
              builder.append(' ').append(rightToken.image).append(' ');
            if (op != null)
            {
              if ("?".equals(op.image))
                builder.append('?').append(' ');
              else
                builder.append(' ').append(op.image).append(' ');
            }
            compiler.appendSourceItem(extent(token), builder.toString());
        expression = Expression(compiler);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SCOPE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case AT:
        case SLASH:
          expression = PrimaryExpression(compiler);
          break;
        default:
          jj_la1[88] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
        String binaryOp = op != null ? op.image : null;
        String rightName = (rightToken != null)  ? rightToken.image : null;
        {if (true) return compiler.getExpressionArtifact().shortCircuitExpression(name, rightName, binaryOp, expression, scToken2.image);}
      break;
    default:
      jj_la1[89] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand Flow(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  IOperand operand;
    if (jj_2_15(3)) {
      operand = FlowExpression(template, compiler);
    } else if (jj_2_16(3)) {
      operand = TemplateExpression(template, compiler);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FACT:
      case SCOPE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case SLASH:
      case 93:
        setSentinal();
        operand = Expression(compiler);
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand FlowExpression(TemplateArtifact template, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token scToken1 = null;
  Token scToken2 = null;
  Token flowToken;
  Token hashToken = null;
  Token patternToken = null;
  IOperand expression = null;
  IOperand innerLoop = null;
  NestedFlowArtifact nestedFlow = null;
  String operator = "&&";
  Group group = null;
  FunctionArtifact parserFunction;
  QualifiedName functionName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QMARK:
      if (jj_2_18(2)) {
        scToken1 = jj_consume_token(QMARK);
        jj_consume_token(QMARK);
        delimitToken = jj_consume_token(LPAREN);
          compiler.addSourceItem("?? (", unit(scToken1), extent(delimitToken));
        expression = Expression(compiler);
        delimitToken = jj_consume_token(RPAREN);
          compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
        innerLoop = Flow(template, compiler);
          expression = compiler.getExpressionArtifact().compactLoop(expression, innerLoop, true);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QMARK:
          scToken1 = jj_consume_token(QMARK);
          if (jj_2_17(2)) {
            scToken2 = jj_consume_token(COLON);
          } else {
            ;
          }
          String source = scToken1.image;
          if (scToken2 != null)
          {
            source += scToken2.image;
            operator = "||";
          }
          else
            scToken2 = scToken1;
          source += " ";
          compiler.addSourceItem(source, unit(scToken1), extent(scToken2));
          expression = Expression(compiler);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 92:
            hashToken = jj_consume_token(92);
            patternToken = jj_consume_token(IDENTIFIER);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LPAREN:
              group = GroupDeclaration(compiler);
              break;
            default:
              jj_la1[91] = jj_gen;
              ;
            }
              compiler.appendSourceItem(extent(hashToken), hashToken.image + patternToken.image);
              expression = compiler.getExpressionArtifact().regularExpression(expression, patternToken.image, group);
            break;
          default:
            jj_la1[92] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            delimitToken = jj_consume_token(LBRACE);
          nestedFlow = nestedFlow = compiler.nestedFlowInstance(template, true);
          compiler.addSourceItem(delimitToken.image + " // branch", unit(delimitToken), extent(delimitToken));
            innerLoop = InnerFlow(nestedFlow, compiler);
            delimitToken = jj_consume_token(RBRACE);
          compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
            break;
          default:
            jj_la1[93] = jj_gen;
            ;
          }
        expression = compiler.getExpressionArtifact().flowExpression(innerLoop, expression, operator);
          break;
        default:
          jj_la1[94] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case LBRACE:
      delimitToken = jj_consume_token(LBRACE);
        compiler.addSourceItem(delimitToken.image + " // loop", unit(delimitToken), extent(delimitToken));
        nestedFlow = compiler.nestedFlowInstance(template, false);
      if (jj_2_19(2)) {
        scToken1 = jj_consume_token(QMARK);
        jj_consume_token(QMARK);
        delimitToken = jj_consume_token(LPAREN);
            compiler.addSourceItem("?? (", unit(scToken1), extent(delimitToken));
        expression = Expression(compiler);
        delimitToken = jj_consume_token(RPAREN);
            compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
        innerLoop = Flow(template, compiler);
            expression = compiler.getExpressionArtifact().compactLoop(expression, innerLoop, false);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AXIOM:
        case BOOLEAN:
        case COMPLEX:
        case CURRENCY:
        case CURSOR:
        case DECIMAL:
        case DOUBLE:
        case FACT:
        case FLOW:
        case INTEGER:
        case LIST:
        case REVERSE:
        case SCOPE:
        case STRING:
        case TERM:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case TRUE:
        case FALSE:
        case UNKNOWN:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case AT:
        case BANG:
        case QMARK:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case SLASH:
        case 93:
          expression = InnerFlow(nestedFlow, compiler);
          break;
        default:
          jj_la1[95] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      delimitToken = jj_consume_token(RBRACE);
        compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      break;
    case FLOW:
      flowToken = jj_consume_token(FLOW);
        compiler.addSourceItem(flowToken.image + " ", unit(flowToken), extent(flowToken));
      functionName = Name(compiler, false, false);
        parserFunction = compiler.functionArtifactInstance(functionName, currentName);
      expression = FunctionCall(parserFunction, compiler);
      break;
    case IDENTIFIER:
      expression = IdentifierPostfix(compiler);
      break;
    default:
      jj_la1[96] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (nestedFlow != null)
      nestedFlow.getParserTemplate().adjustContextName();
    {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand IdentifierPostfix(Compiler compiler) throws ParseException
 {
  Token nameToken = null;
  Token postfixToken = null;
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      postfixToken = jj_consume_token(INCR);
      break;
    case DECR:
      postfixToken = jj_consume_token(DECR);
      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    compiler.addSourceItem(nameToken.image + postfixToken.image, unit(nameToken), extent(postfixToken));
    {if (true) return compiler.getExpressionArtifact().identifierPostfix(nameToken.image, postfixToken.image);}
    throw new Error("Missing return statement in function");
  }

  final public IOperand InnerFlow(NestedFlowArtifact nestedFlow, Compiler compiler) throws ParseException
 {
  IOperand operand;
  SourceMarker sourceMarker = null;
  if (!nestedFlow.isRunOnce())
    sourceMarker = compiler.pushSourceMarker("InnerFlow");
    operand = Flow(nestedFlow.getParserTemplate(), compiler);
      nestedFlow.getTemplate().addTerm(operand);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[98] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      operand = Flow(nestedFlow.getParserTemplate(), compiler);
        nestedFlow.getTemplate().addTerm(operand);
    }
    if (sourceMarker != null)
    {
      sourceMarker.checkForShortCircuit();
      compiler.popSourceMarker();
    }
    {if (true) return compiler.innerFlow(nestedFlow.getTemplate(), nestedFlow.isRunOnce());}
    throw new Error("Missing return statement in function");
  }

  final public IOperand TemplateTerm(ITemplate template, Compiler compiler) throws ParseException
 {
  Token assignToken = null;
  Token equalsToken = null;
  Token hashToken = null;
  Token patternToken = null;
  TermArtifact parserTerm;
  IOperand operand = null;
  IOperand expression = null;
  QualifiedName qname = null;
  IVariableSpec varSpec= null;
  ListReference listReference = null;
  resetItemToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
    case IDENTIFIER:
    case AT:
    case SLASH:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case COMPLEX:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case INTEGER:
      case STRING:
        varSpec = Type(compiler);
        break;
      default:
        jj_la1[99] = jj_gen;
        ;
      }
      qname = Name(compiler, true, varSpec != null);
    StringBuilder builder = new StringBuilder();
    if (varSpec != null)
      builder.append(varSpec.getSource()).append(' ');
    builder.append(currentName);
    compiler.addSourceItem(builder.toString(), unit(itemToken), extent(token));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case RARROW:
        listReference = IndexExpression(compiler);
        break;
      default:
        jj_la1[100] = jj_gen;
        ;
      }
    parserTerm = compiler.termArtifactInstance(varSpec, qname, listReference);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
      case ASSIGN:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
      case 92:
        if (jj_2_21(3)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASSIGN:
            equalsToken = jj_consume_token(ASSIGN);
            compiler.appendSourceItem(extent(equalsToken), equalsToken.image);
            parserTerm.setOperator(equalsToken.image);
            break;
          case PLUSASSIGN:
            assignToken = jj_consume_token(PLUSASSIGN);
            compiler.appendSourceItem(extent(assignToken), assignToken.image);
            parserTerm.setOperator(assignToken.image);
            break;
          default:
            jj_la1[101] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOOLEAN:
          case COMPLEX:
          case CURRENCY:
          case DECIMAL:
          case DOUBLE:
          case FACT:
          case INTEGER:
          case SCOPE:
          case STRING:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case STRING_LITERAL:
          case TRUE:
          case FALSE:
          case UNKNOWN:
          case IDENTIFIER:
          case LPAREN:
          case AT:
          case BANG:
          case INCR:
          case DECR:
          case PLUS:
          case MINUS:
          case SLASH:
          case 93:
            if (jj_2_20(3)) {
              expression = Expression(compiler);
              parserTerm.setExpression(expression);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BOOLEAN:
              case COMPLEX:
              case CURRENCY:
              case DECIMAL:
              case DOUBLE:
              case INTEGER:
              case STRING:
                expression = TypedLiteralTerm(compiler);
              parserTerm.setLiteral(expression);
                break;
              default:
                jj_la1[102] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          case AXIOM:
            TermAxiomList(parserTerm, compiler);
            break;
          case LIST:
          case MAP:
            operand = Map(template, parserTerm, compiler);
            break;
          default:
            jj_la1[103] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUSASSIGN:
          case STARASSIGN:
          case SLASHASSIGN:
          case ANDASSIGN:
          case ORASSIGN:
          case XORASSIGN:
          case REMASSIGN:
          case RSIGNEDSHIFTASSIGN:
          case RUNSIGNEDSHIFTASSIGN:
            ReflexiveAssign(parserTerm, compiler);
            break;
          case LPAREN:
            Arguments(parserTerm, compiler);
            break;
          case 92:
            hashToken = jj_consume_token(92);
            patternToken = jj_consume_token(IDENTIFIER);
         compiler.appendSourceItem(extent(hashToken), hashToken.image + patternToken.image);
         IOperand regexOp = compiler.getExpressionArtifact().regularExpression(qname, patternToken.image);
         operand = compiler.getTermFactoryArtifact().createRegexTerm(regexOp);
            break;
          default:
            jj_la1[104] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[105] = jj_gen;
        ;
      }
    if (operand == null)
      operand = compiler.getTermFactoryArtifact().templateTerm(parserTerm);
    {if (true) return operand;}
      break;
    case TERM:
      operand = AnonTemplateTerm(compiler);
    {if (true) return operand;}
      break;
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand AnonTemplateTerm(Compiler compiler) throws ParseException
 {
  Token termToken;
  IOperand expression;
    termToken = jj_consume_token(TERM);
     compiler.addSourceItem("", unit(termToken), extent(termToken));
     resetItemToken();
    expression = Expression(compiler);
    {if (true) return compiler.getTermFactoryArtifact().templateTerm(expression);}
    throw new Error("Missing return statement in function");
  }

  final public void TermAxiomList(TermArtifact parserTerm, Compiler compiler) throws ParseException
 {
  Token axiomToken;
  Token assignToken;
  Token nameToken;
  String source;
  ITemplate template = null;
  QualifiedName axiomQname = QualifiedName.ANONYMOUS;
    axiomToken = jj_consume_token(AXIOM);
    source = axiomToken.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      axiomQname = AxiomKeyName(compiler);
      source += (" " + currentName);
      break;
    default:
      jj_la1[107] = jj_gen;
      ;
    }
    compiler.appendSourceItem(extent(token), source);
    template = TermsInitializer(axiomQname, compiler);
    parserTerm.assignAxiomList(axiomQname, template);
  }

  final public IOperand Map(ITemplate template, TermArtifact parserTerm, Compiler compiler) throws ParseException
 {
  Token keywordToken;
  Token nameToken;
  Token braceToken;
  Token scopeToken = null;
  Token listToken = null;
  ChoiceArtifact parserChoice;
  int selection = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      listToken = jj_consume_token(LIST);
      break;
    default:
      jj_la1[108] = jj_gen;
      ;
    }
    keywordToken = jj_consume_token(MAP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      scopeToken = jj_consume_token(SCOPE);
      jj_consume_token(DOT);
      break;
    default:
      jj_la1[109] = jj_gen;
      ;
    }
    nameToken = jj_consume_token(IDENTIFIER);
    String source = keywordToken.image + " " + nameToken.image;
    compiler.addSourceItem(source, unit(keywordToken), extent(nameToken));
    parserChoice = compiler.choiceArtifactInstance(nameToken.image, true);
    if (scopeToken != null) {
      IOperand scopeFunction = compiler.getFunctionFactoryArtifact().createScopeFunction(QualifiedName.SCOPE, nameToken.image);
      parserChoice.setValueExpression(scopeFunction);
    }
    braceToken = jj_consume_token(LBRACE);
    compiler.appendSourceItem(extent(braceToken), braceToken.image);
    label_17:
    while (true) {
      Selection(selection++, parserChoice, listToken != null, compiler);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QMARK:
        ;
        break;
      default:
        jj_la1[110] = jj_gen;
        break label_17;
      }
    }
    braceToken = jj_consume_token(RBRACE);
    compiler.appendSourceItem(extent(braceToken), braceToken.image);
    {if (true) return parserChoice.getMap(parserTerm.getQname(), template, listToken != null);}
    throw new Error("Missing return statement in function");
  }

  final public ITemplate TermsInitializer(QualifiedName axiomName, Compiler compiler) throws ParseException
 {
  Token braceToken;
  ITemplate template = null;
    itemToken = jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TERM:
    case IDENTIFIER:
      template = Expressions(axiomName.toString(), compiler);
      break;
    default:
      jj_la1[111] = jj_gen;
      ;
    }
    braceToken = jj_consume_token(RBRACE);
    compiler.appendSourceItem(extent(braceToken), braceToken.image);
    {if (true) return compiler.getAxiomInterface().axiomInitializer(axiomName, template);}
    throw new Error("Missing return statement in function");
  }

  final public ITemplate Expressions(String axiomKey, Compiler compiler) throws ParseException
 {
  Token nameToken;
  Token termToken;
  Token assignToken = null;
  String identifier = null;
  IOperand expression = null;
  ListReference listReference = null;
  ITemplate template = compiler.chainTemplate();
  template.setKey(axiomKey);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      nameToken = jj_consume_token(IDENTIFIER);
      identifier = nameToken.image;
      compiler.addSourceItem(identifier + " ", unit(nameToken), extent(nameToken));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case RARROW:
        listReference = IndexExpression(compiler);
        break;
      default:
        jj_la1[112] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
                        compiler.appendSourceItem(extent(assignToken), assignToken.image);
        expression = Expression(compiler);
        break;
      default:
        jj_la1[113] = jj_gen;
        ;
      }
      break;
    case TERM:
      termToken = jj_consume_token(TERM);
      identifier = "";
      compiler.addSourceItem("", unit(termToken), extent(termToken));
      expression = Expression(compiler);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    template.addTerm(compiler.termExpression(identifier, expression, listReference));
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        nameToken = jj_consume_token(IDENTIFIER);
        identifier = nameToken.image;
        compiler.addSourceItem(identifier + " ", unit(nameToken), extent(nameToken));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case RARROW:
          listReference = IndexExpression(compiler);
          break;
        default:
          jj_la1[116] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
          assignToken = jj_consume_token(ASSIGN);
                          compiler.appendSourceItem(extent(assignToken), assignToken.image);
          expression = Expression(compiler);
          break;
        default:
          jj_la1[117] = jj_gen;
          ;
        }
        break;
      case TERM:
        termToken = jj_consume_token(TERM);
        identifier = "";
        compiler.addSourceItem("", unit(termToken), extent(termToken));
        expression = Expression(compiler);
        break;
      default:
        jj_la1[118] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      template.addTerm(compiler.termExpression(identifier, expression, listReference));
    }
    {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public void ReflexiveAssign(TermArtifact parserTerm, Compiler compiler) throws ParseException
 {
  Token assignToken;
  IOperand expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUSASSIGN:
      assignToken = jj_consume_token(MINUSASSIGN);
      break;
    case STARASSIGN:
      assignToken = jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      assignToken = jj_consume_token(SLASHASSIGN);
      break;
    case ANDASSIGN:
      assignToken = jj_consume_token(ANDASSIGN);
      break;
    case ORASSIGN:
      assignToken = jj_consume_token(ORASSIGN);
      break;
    case XORASSIGN:
      assignToken = jj_consume_token(XORASSIGN);
      break;
    case REMASSIGN:
      assignToken = jj_consume_token(REMASSIGN);
      assignToken = jj_consume_token(LSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGN:
      assignToken = jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      assignToken = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    default:
      jj_la1[119] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    compiler.appendSourceItem(extent(assignToken), assignToken.image);
    parserTerm.setOperator(assignToken.image);
    expression = Expression(compiler);
    parserTerm.reflexiveAssign(assignToken.image, expression);
  }

  final public IOperand Literals(String name, boolean isNot, Compiler compiler) throws ParseException
 {
  Token braceToken;
  List<Parameter> literalList = null;
  resetItemToken();
    braceToken = jj_consume_token(LBRACE);
                         intercept(braceToken, compiler);
    literalList = LiteralList(compiler);
    braceToken = jj_consume_token(RBRACE);
    StringBuilder builder = new StringBuilder(" ");
    builder.append('{');
    for (Parameter item: literalList)
      builder.append(display(item.getValue()));
    builder.append('}');
    compiler.appendSourceItem(extent(braceToken), builder.toString());
    {if (true) return compiler.getExpressionArtifact().literals(name, isNot, literalList);}
    throw new Error("Missing return statement in function");
  }

  final public void Arguments(TermArtifact parserTerm, Compiler compiler) throws ParseException
 {
  ITemplate parameterTemplate = null;
    itemToken = jj_consume_token(LPAREN);
      compiler.appendSourceItem(extent(token), itemToken.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
    case TERM:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case MINUS:
      parameterTemplate = Parameters(parserTerm.getQname().toString(), compiler, true);
      break;
    default:
      jj_la1[120] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
      compiler.appendSourceItem(extent(token), token.image);
    parserTerm.setParameterTemplate(parameterTemplate);
  }

  final public List<Parameter> LiteralList(Compiler compiler) throws ParseException
 {
  List<Parameter>  literalList = new ArrayList<Parameter>();
  Parameter parameter;
    parameter = LiteralTerm(compiler);
    literalList.add(parameter);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[121] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      parameter = LiteralTerm(compiler);
      literalList.add(parameter);
    }
    {if (true) return literalList;}
    throw new Error("Missing return statement in function");
  }

  final public void Selection(int selection, ChoiceArtifact parserChoice, boolean isList, Compiler compiler) throws ParseException
 {
  Token delimToken;
  IOperand operand;
  QualifiedName qname;
  setSentinal();
    operand = ShortCircuitExpression(parserChoice.getName(), compiler);
    delimToken = jj_consume_token(COLON);
    compiler.appendSourceItem(extent(delimToken), delimToken.image);
    compiler.getAxiomInterface().fact(parserChoice.getQualifiedAxiomName(), new Parameter(Term.ANONYMOUS, ""));
    if (jj_2_22(3)) {
      SelectionTerm(parserChoice, compiler);
        if (isList)
              {if (true) throw new SyntaxException("Only identifier not allowed as list map value");}
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[122] = jj_gen;
          break label_20;
        }
        delimToken = jj_consume_token(COMMA);
          compiler.appendSourceItem(extent(delimToken), delimToken.image);
        SelectionTerm(parserChoice, compiler);
      }
      compiler.getChoiceFactoryArtifact().selection(parserChoice, operand);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case AT:
      case SLASH:
        qname = Name(compiler, true, false);
      if (!isList)
            {if (true) throw new SyntaxException("Identifier not allowed as select value");}
          compiler.appendSourceItem(extent(token), currentName);
          compiler.getChoiceFactoryArtifact().selectionList(parserChoice.getQualifiedAxiomName(), qname, currentName);
      compiler.getChoiceFactoryArtifact().selection(parserChoice, operand);
        break;
      default:
        jj_la1[123] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void SelectionTerm(ChoiceArtifact parserChoice, Compiler compiler) throws ParseException
 {
  Token nameToken;
  resetItemToken();
    Fact(parserChoice.getQualifiedAxiomName(), false, compiler);
    compiler.appendSourceItem(extent(token), currentName);
  }

  final public IOperand ParameterExpression(Compiler compiler, boolean isFirst) throws ParseException
 {
  Token macroToken;
  Token termToken = null;
  Token identifierToken = null;
  Token postfixToken = null;
  Parameter parameter = null;
  ListReference listReference = null;
  IOperand inputOp = null;
  IOperand expression = null;
  String identifier = null;
  String name = Term.ANONYMOUS;
  String source = isFirst ? itemToken.image : "";
  SourceItem sourceItem = null;
  if (!isFirst)
    resetItemToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      identifierToken = jj_consume_token(IDENTIFIER);
        intercept(identifierToken, compiler);
        identifier = identifierToken.image;
        source += identifier;
        sourceItem = compiler.addSourceItem(source, unit(itemToken), extent(identifierToken));
        name = identifier;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case RARROW:
      case ASSIGN:
      case INCR:
      case DECR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case RARROW:
          listReference = IndexExpression(compiler);
          break;
        case INCR:
        case DECR:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INCR:
            postfixToken = jj_consume_token(INCR);
            break;
          case DECR:
            postfixToken = jj_consume_token(DECR);
            break;
          default:
            jj_la1[124] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
            inputOp = compiler.getExpressionArtifact().cursorPostfixExpression( compiler.name(identifier, true, false), postfixToken.image);
            sourceItem.append(extent(postfixToken), postfixToken.image);
          break;
        case ASSIGN:
          jj_consume_token(ASSIGN);
                sourceItem.append(extent(token), "=");
          if (jj_2_23(3)) {
            expression = Literal(compiler);
              parameter = new Parameter(Term.ANONYMOUS, expression.getValue());
              expression = null;
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case FACT:
            case SCOPE:
            case INTEGER_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case TRUE:
            case FALSE:
            case UNKNOWN:
            case IDENTIFIER:
            case LPAREN:
            case AT:
            case BANG:
            case INCR:
            case DECR:
            case PLUS:
            case MINUS:
            case SLASH:
            case 93:
              expression = Expression(compiler);
              break;
            case BOOLEAN:
            case COMPLEX:
            case CURRENCY:
            case DECIMAL:
            case DOUBLE:
            case INTEGER:
            case STRING:
              expression = TypedLiteralTerm(compiler);
              break;
            default:
              jj_la1[125] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[126] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[127] = jj_gen;
        ;
      }
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case MINUS:
      parameter = LiteralTerm(compiler);
      compiler.appendSourceItem(extent(token), source, display(parameter.getValue()));
      break;
    case TERM:
      termToken = jj_consume_token(TERM);
          intercept(termToken, compiler);
          identifier = "";
          source += termToken.image;
          sourceItem = compiler.addSourceItem(source, unit(itemToken), extent(termToken));
      expression = Expression(compiler);
      break;
    default:
      jj_la1[128] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (inputOp != null)
      {if (true) return inputOp;}
    if (expression != null)
      {if (true) return compiler.getExpressionArtifact().parameterExpression(name, expression);}
    if (listReference != null)
      {if (true) return compiler.getListFactoryArtifact().listReference(compiler.name(identifier, true, false), listReference);}
    if (parameter != null)
      {if (true) return compiler.getExpressionArtifact().parameterExpression(name, parameter);}
    else
      {if (true) return compiler.getExpressionArtifact().parameterExpression(name, compiler.name(identifier, true, false));}
    throw new Error("Missing return statement in function");
  }

  final public void ListItemAssign(Compiler compiler) throws ParseException
 {
  Token nameToken;
  Token assignToken;
  QualifiedName name;
  ListReference listReference;
  IOperand expression = null;
  currentNonTerminal = "ListItemAssign";
  compiler.setSourceMarker(currentNonTerminal);
  resetItemToken();
    name = Name(compiler, true, false);
     compiler.addSourceItem(currentName, unit(itemToken), extent(token));
    listReference = IndexExpression(compiler);
    resetItemToken();
    assignToken = jj_consume_token(ASSIGN);
    compiler.appendSourceItem(extent(assignToken), assignToken.image);
    expression = Expression(compiler);
     compiler.getListFactoryArtifact().listItemAssign(name, listReference, expression);
  }

  final public IVariableSpec Type(Compiler compiler) throws ParseException
 {
  Token literalToken;
  Token ccToken = null;
  Token identifier = null;
  Token stringToken = null;
  String source;
  QualifiedName qualifierName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      literalToken = jj_consume_token(INTEGER);
      break;
    case BOOLEAN:
      literalToken = jj_consume_token(BOOLEAN);
      break;
    case DOUBLE:
      literalToken = jj_consume_token(DOUBLE);
      break;
    case STRING:
      literalToken = jj_consume_token(STRING);
      break;
    case DECIMAL:
      literalToken = jj_consume_token(DECIMAL);
      break;
    case CURRENCY:
      literalToken = jj_consume_token(CURRENCY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        ccToken = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[129] = jj_gen;
        ;
      }
      if (jj_2_24(2)) {
        jj_consume_token(AT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          identifier = jj_consume_token(IDENTIFIER);
          break;
        case STRING_LITERAL:
          stringToken = jj_consume_token(STRING_LITERAL);
          break;
        default:
          jj_la1[130] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      break;
    case COMPLEX:
      literalToken = jj_consume_token(COMPLEX);
      break;
    default:
      jj_la1[131] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    intercept(literalToken, compiler);
    Unit literalUnit = unit(literalToken);
    source = literalToken.image;
    String qualifier = "";
    if (ccToken != null) {
      source += ("." + ccToken.image);
      qualifier = ccToken.image;
    }
    if (identifier != null) {
       source += (" @" + identifier.image);
       qualifierName = compiler.name(identifier.image, true, false);
    } else if (stringToken != null) {
      source += (" @ " + stringToken.image);
      qualifier += ("@" + getText(stringToken));
    }
    {if (true) return compiler.getVariableArtifact().variableSpec(literalUnit.getKind(), qualifier, qualifierName, source);}
    throw new Error("Missing return statement in function");
  }

  final public IVariableSpec ListType(Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token axiomToken = null;
  IVariableSpec varSpec = null;
  String source;
    delimitToken = jj_consume_token(LT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
      varSpec = Type(compiler);
      break;
    case AXIOM:
      axiomToken = jj_consume_token(AXIOM);
      break;
    case TERM:
      jj_consume_token(TERM);
      break;
    default:
      jj_la1[132] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    intercept(delimitToken, compiler);
    if (varSpec != null) {
      source = "<" + varSpec.getSource() + ">";
      varSpec.setSource(source);
    } else if (axiomToken != null) {
      varSpec = compiler.getVariableArtifact().variableSpec(TaqLiteral.axiom, null, null, "<axiom>");
    } else {
      varSpec = compiler.getVariableArtifact().variableSpec(TaqLiteral.term, null, null, "<term>");
    }
    {if (true) return varSpec;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName AxiomName(Compiler compiler) throws ParseException
 {
  QualifiedName axiomName;
    axiomName = Name(compiler, true, false);
    axiomName = compiler.axiomName(axiomName);
    {if (true) return axiomName;}
    throw new Error("Missing return statement in function");
  }

  final public void AxiomSpecification(QualifiedName qualifiedAxiomName, boolean isList, boolean isExport, Compiler compiler) throws ParseException
 {
  String termNames;
  int count = 0;
  resetItemToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      termNames = TermHeader(qualifiedAxiomName, isList, isExport, compiler);
      compiler.addSourceItem(termNames, unit(itemToken), extent(token));
      break;
    default:
      jj_la1[133] = jj_gen;
      ;
    }
    label_21:
    while (true) {
      AxiomItem(qualifiedAxiomName, isExport, compiler);
                                                        ++count;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[134] = jj_gen;
        break label_21;
      }
    }
     if (!isList && (count > 1))
       {if (true) throw new SyntaxException("Use \u005c"list\u005c" keyword to specify more than one axiom");}
  }

  final public void AxiomItem(QualifiedName qualifiedAxiomName, boolean isExport, Compiler compiler) throws ParseException
 {
  Token braceToken;
  Token delimitToken;
    braceToken = jj_consume_token(LBRACE);
    compiler.addSourceItem(braceToken.image, unit(braceToken), extent(braceToken));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BIT_OR:
      jj_consume_token(BIT_OR);
      break;
    default:
      jj_la1[135] = jj_gen;
      ;
    }
    Fact(qualifiedAxiomName, isExport, compiler);
    label_22:
    while (true) {
      if (jj_2_25(2)) {
        ;
      } else {
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        delimitToken = jj_consume_token(COMMA);
        break;
      case BIT_OR:
        delimitToken = jj_consume_token(BIT_OR);
        break;
      default:
        jj_la1[136] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      Fact(qualifiedAxiomName, isExport, compiler);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BIT_OR:
      jj_consume_token(BIT_OR);
      break;
    default:
      jj_la1[137] = jj_gen;
      ;
    }
    braceToken = jj_consume_token(RBRACE);
    compiler.appendSourceItem(extent(braceToken), braceToken.image);
    compiler.getAxiomInterface().axiomItem(qualifiedAxiomName);
  }

  final public void Fact(QualifiedName qualifiedAxiomName, boolean isExport, Compiler compiler) throws ParseException
 {
  Token unknownToken;
  IOperand operand;
  Parameter param = null;
  resetItemToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case LIST:
    case STRING:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case MINUS:
        param = LiteralTerm(compiler);
        break;
      case LIST:
        param = List(isExport, compiler);
        break;
      case BOOLEAN:
      case COMPLEX:
      case CURRENCY:
      case DECIMAL:
      case DOUBLE:
      case INTEGER:
      case STRING:
        operand = TypedLiteralTerm(compiler);
                                           param = operand.toParameter();
        break;
      case IDENTIFIER:
        param = Function(compiler);
        break;
      default:
        jj_la1[138] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.getAxiomInterface().fact(qualifiedAxiomName, param);
      break;
    case NAN:
      unknownToken = jj_consume_token(NAN);
      intercept(unknownToken, compiler);
      param = compiler.getAxiomInterface().nan(qualifiedAxiomName);
      break;
    case QMARK:
      unknownToken = jj_consume_token(QMARK);
      intercept(unknownToken, compiler);
      param = compiler.getAxiomInterface().blank(qualifiedAxiomName);
      break;
    default:
      jj_la1[139] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    compiler.appendSourceItem(extent(token), display(param.getValue()));
  }

  final public Parameter List(boolean isExport, Compiler compiler) throws ParseException
 {
  Token listToken;
  QualifiedName target = null;
    listToken = jj_consume_token(LIST);
    target = Name(compiler, true, false);
        compiler.addSourceItem(listToken.image + " " + target.toString(), unit(listToken), extent(token));
        {if (true) return compiler.getVariableArtifact().getListVariable(target, isExport).toParameter();}
    throw new Error("Missing return statement in function");
  }

  final public IOperand TypedLiteralTerm(Compiler compiler) throws ParseException
 {
  IVariableSpec varSpec;
  Parameter literal;
  resetItemToken();
    varSpec = Type(compiler);
    literal = LiteralTerm(compiler);
    compiler.appendSourceItem(extent(itemToken), varSpec.getSource(), " ", literal.toString() );
    {if (true) return compiler.getLiteralArtifact().typedLiteralTerm(varSpec, literal);}
    throw new Error("Missing return statement in function");
  }

  final public Parameter Function(Compiler compiler) throws ParseException
 {
  Token name;
  Token library;
  Token quoteToken;
  String arguments = null;
  List<Term> termList = new ArrayList<Term>();
    library = jj_consume_token(IDENTIFIER);
    intercept(library, compiler);
    jj_consume_token(DOT);
    name = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      arguments = TermList(termList, compiler);
      break;
    default:
      jj_la1[140] = jj_gen;
      ;
    }
    String source = library.image + "." + name.image;
    if (arguments != null)
      source += arguments;
    compiler.appendSourceItem(extent(name), source);
    {if (true) return compiler.getFunctionFactoryArtifact().function(library.image, name.image, termList);}
    throw new Error("Missing return statement in function");
  }

  final public String TermList(List<Term> termList, Compiler compiler) throws ParseException
 {
  String term;
  StringBuilder builder = new StringBuilder("(");
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case AT:
    case MINUS:
    case SLASH:
      term = TermDeclaration(termList, compiler);
      builder.append(term);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[141] = jj_gen;
          break label_23;
        }
        jj_consume_token(COMMA);
        term = TermDeclaration(termList, compiler);
        builder.append(',').append(term);
      }
      break;
    default:
      jj_la1[142] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    builder.append(')');
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TermDeclaration(List<Term> termList, Compiler compiler) throws ParseException
 {
  Parameter param;
  IOperand operand;
  String name = Term.ANONYMOUS;
    if (jj_2_26(2)) {
      Name(compiler, false, false);
                                                name = currentName;
      jj_consume_token(ASSIGN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case MINUS:
      param = LiteralTerm(compiler);
      break;
    case BOOLEAN:
    case COMPLEX:
    case CURRENCY:
    case DECIMAL:
    case DOUBLE:
    case INTEGER:
    case STRING:
      operand = TypedLiteralTerm(compiler);
                                         param = operand.toParameter();
      break;
    default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     String value = display(param.getValue());
     termList.add(new Parameter(name, param.getValue()));
     if (name.isEmpty())
       {if (true) return value;}
     {if (true) return name + "="+value;}
    throw new Error("Missing return statement in function");
  }

  final public String TermHeader(QualifiedName qualifiedAxiomName, boolean isList, boolean isExport, Compiler compiler) throws ParseException
 {
  Token encloseToken;
  String termName;
  StringBuilder builder = new StringBuilder();
  if (isList)
    compiler.getAxiomInterface().createAxiomItemList(qualifiedAxiomName, isExport);
  else
    compiler.getAxiomInterface().createAxiom(qualifiedAxiomName, isExport);
    encloseToken = jj_consume_token(LPAREN);
                     intercept(encloseToken, compiler);
    builder.append('(');
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      termName = TermName(qualifiedAxiomName, compiler);
          builder.append(termName);
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[144] = jj_gen;
          break label_24;
        }
        jj_consume_token(COMMA);
        termName = TermName(qualifiedAxiomName, compiler);
            builder.append(',').append(termName);
      }
      break;
    default:
      jj_la1[145] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    builder.append(')');
    {if (true) return builder.toString();}
    throw new Error("Missing return statement in function");
  }

  final public List<String> DynamicTermHeader(Compiler compiler) throws ParseException
 {
  Token encloseToken;
  Token nameToken;
  String termName;
  List<String> termNameList = new ArrayList<String>();
  StringBuilder builder = new StringBuilder();
    encloseToken = jj_consume_token(LPAREN);
    builder.append(encloseToken.image);
    nameToken = jj_consume_token(IDENTIFIER);
    termName = nameToken.image;
    builder.append(termName);
    termNameList.add(termName);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[146] = jj_gen;
        break label_25;
      }
      jj_consume_token(COMMA);
      nameToken = jj_consume_token(IDENTIFIER);
      termName = nameToken.image;
      builder.append(',').append(termName);
      termNameList.add(termName);
    }
    encloseToken = jj_consume_token(RPAREN);
    builder.append(encloseToken.image);
    compiler.appendSourceItem(extent(encloseToken), builder.toString());
    {if (true) return termNameList;}
    throw new Error("Missing return statement in function");
  }

  final public String TermName(QualifiedName qualifiedAxiomName, Compiler compiler) throws ParseException
 {
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    compiler.getAxiomInterface().addAxiomTermName(qualifiedAxiomName, nameToken.image);
    {if (true) return nameToken.image;}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName Name(Compiler compiler, boolean isContextName, boolean isDeclaration) throws ParseException
 {
  Token pathToken;
  Token partToken1;
  Token partToken2;
  StringBuilder builder = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      pathToken = jj_consume_token(SLASH);
        intercept(pathToken, compiler);
        builder.append('/');
      partToken1 = jj_consume_token(IDENTIFIER);
        builder.append(partToken1.image);
      break;
    case AT:
      pathToken = jj_consume_token(AT);
        intercept(pathToken, compiler);
        builder.append('@');
      partToken1 = jj_consume_token(IDENTIFIER);
      jj_consume_token(DOT);
      partToken2 = jj_consume_token(IDENTIFIER);
        builder.append(partToken1.image).append('.').append(partToken2.image);
      break;
    case IDENTIFIER:
      partToken1 = jj_consume_token(IDENTIFIER);
        intercept(partToken1, compiler);
        builder.append(partToken1.image);
      if (jj_2_27(2)) {
        NamePart(builder);
      } else {
        ;
      }
      break;
    default:
      jj_la1[147] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    currentName = builder.toString();
    {if (true) return compiler.name(currentName, isContextName, isDeclaration);}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName AxiomKeyName(Compiler compiler) throws ParseException
 {
  Token partToken1;
  Token dotToken = null;
  Token atToken = null;
  Token partToken2 = null;
  StringBuilder builder = new StringBuilder();
    partToken1 = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
    case AT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        dotToken = jj_consume_token(DOT);
        break;
      case AT:
        atToken = jj_consume_token(AT);
        break;
      default:
        jj_la1[148] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        partToken2 = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[149] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[150] = jj_gen;
      ;
    }
    intercept(partToken1, compiler);
    boolean hasName2 = (partToken2 != null);
    if (hasName2 && (dotToken != null)) {
      currentName = partToken1.image + "." + partToken2.image;
      builder.append(partToken2.image).append('@').append(partToken1.image);
    } else if (hasName2 && (atToken != null)) {
      currentName = partToken1.image + "@" + partToken2.image;
      builder.append(currentName);
    } else if (atToken != null) {
      currentName = partToken1.image + "@";
      builder.append(currentName);
    } else if (dotToken == null) {
      currentName = partToken1.image;
      builder.append(partToken1.image).append('@').append(compiler.getScopeName());
    } else
        {if (true) throw new SyntaxException("Invalid axiom key name: " + partToken1.image + ".");}
    {if (true) return compiler.name(builder.toString(), false, false);}
    throw new Error("Missing return statement in function");
  }

  final public QualifiedName TemplateName(Compiler compiler) throws ParseException
 {
  Token partToken1;
  Token dotToken = null;
  Token atToken = null;
  Token partToken2 = null;
  StringBuilder builder = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      atToken = jj_consume_token(AT);
                  intercept(atToken, compiler);
      break;
    default:
      jj_la1[151] = jj_gen;
      ;
    }
    partToken1 = jj_consume_token(IDENTIFIER);
                             intercept(partToken1, compiler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      dotToken = jj_consume_token(DOT);
      partToken2 = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[152] = jj_gen;
      ;
    }
    boolean hasName2 = partToken2 != null;
    if (hasName2) {
      currentName = partToken1.image + "." + partToken2.image;
      if (atToken != null) {
        currentName = "@" + currentName;
        builder.append(currentName);
      } else
        builder.append('@').append(partToken1.image).append('.').append(partToken2.image);
    } else {
      currentName = partToken1.image;
      builder.append('@').append(compiler.getScopeName()).append('.').append(partToken1.image);
    }
    {if (true) return compiler.name(builder.toString(), false, false);}
    throw new Error("Missing return statement in function");
  }

  final public void NamePart(StringBuilder builder) throws ParseException
 {
  Token partToken = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      jj_consume_token(AT);
      if (jj_2_28(2)) {
        partToken = jj_consume_token(IDENTIFIER);
      } else {
        ;
      }
      builder.append('@');
      if (partToken != null)
        builder.append(partToken.image);
      break;
    case DOT:
      jj_consume_token(DOT);
      partToken = jj_consume_token(IDENTIFIER);
      builder.append('.').append(partToken.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        partToken = jj_consume_token(IDENTIFIER);
        builder.append('.').append(partToken.image);
        break;
      default:
        jj_la1[153] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[154] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void InitialiserList(InitialProperties properties, Compiler compiler) throws ParseException
 {
  Token delimitToken;
    delimitToken = jj_consume_token(LPAREN);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    InitialiserDeclaration(properties, compiler);
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[155] = jj_gen;
        break label_26;
      }
      delimitToken = jj_consume_token(COMMA);
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      InitialiserDeclaration(properties, compiler);
    }
    delimitToken = jj_consume_token(RPAREN);
    compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
  }

  final public String InitialiserDeclaration(InitialProperties properties, Compiler compiler) throws ParseException
 {
  String name;
  QualifiedName qname;
  Parameter param;
    qname = Name(compiler, false, false);
    jj_consume_token(ASSIGN);
    param = LiteralTerm(compiler);
    compiler.appendSourceItem(extent(itemToken), currentName, "=", display(param.getValue()));
    {if (true) return properties.initializerDeclaration(qname, param.getValue());}
    throw new Error("Missing return statement in function");
  }

  final public Parameter LiteralTerm(Compiler compiler) throws ParseException
 {
  Token lit;
  Token minus = null;
  Parameter param;
  boolean flag;
    if (jj_2_29(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        minus = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[156] = jj_gen;
        ;
      }
      lit = jj_consume_token(INTEGER_LITERAL);
    intercept(lit, compiler);
    param = new IntegerTerm(minus == null ? lit.image : minus.image + lit.image);
    {if (true) return param;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOATING_POINT_LITERAL:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          minus = jj_consume_token(MINUS);
          break;
        default:
          jj_la1[157] = jj_gen;
          ;
        }
        lit = jj_consume_token(FLOATING_POINT_LITERAL);
    intercept(lit, compiler);
    param = new DoubleTerm(minus == null ? lit.image : minus.image + lit.image);
    {if (true) return param;}
        break;
      case STRING_LITERAL:
        lit = jj_consume_token(STRING_LITERAL);
    intercept(lit, compiler);
    param = new StringTerm(getText(lit));
    {if (true) return param;}
        break;
      case TRUE:
      case FALSE:
        flag = BooleanLiteral(compiler);
    {if (true) return new BooleanTerm(flag);}
        break;
      case UNKNOWN:
        UnknownLiteral(compiler);
    {if (true) return new LiteralParameter(Term.ANONYMOUS, new Unknown(), LiteralType.unknown);}
        break;
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanLiteral(Compiler compiler) throws ParseException
 {
  Token lit;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      lit = jj_consume_token(TRUE);
    intercept(lit, compiler);
    {if (true) return true;}
      break;
    case FALSE:
      lit = jj_consume_token(FALSE);
    intercept(lit, compiler);
    {if (true) return false;}
      break;
    default:
      jj_la1[159] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void UnknownLiteral(Compiler compiler) throws ParseException
 {
  Token lit;
    lit = jj_consume_token(UNKNOWN);
     intercept(lit, compiler);
  }

  final public void Include(Compiler compiler) throws ParseException
 {
  Token keywordToken = null;
  Token includeToken = null;
  currentNonTerminal = "Include";
  compiler.setSourceMarker(currentNonTerminal);
    keywordToken = jj_consume_token(INCLUDE);
    includeToken = jj_consume_token(STRING_LITERAL);
    compiler.addSourceItem(keywordToken.image + " " + includeToken.image, unit(keywordToken), extent(token));
    compiler.includeResource(getText(includeToken));
  }

  final public IOperand Expression(Compiler compiler) throws ParseException
 {
  IOperand param;
  Token assignToken = null;
  IOperand assignOperand = null;
  if (currentNonTerminal.equals(SourceTracker.INPUT)) {
    currentNonTerminal = "Expression";
    compiler.setSourceMarker(currentNonTerminal);
    setSentinal();
  }
    param = ConditionalOrExpression(compiler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        assignToken = jj_consume_token(ASSIGN);
        break;
      case PLUSASSIGN:
        assignToken = jj_consume_token(PLUSASSIGN);
        break;
      case MINUSASSIGN:
        assignToken = jj_consume_token(MINUSASSIGN);
        break;
      case STARASSIGN:
        assignToken = jj_consume_token(STARASSIGN);
        break;
      case SLASHASSIGN:
        assignToken = jj_consume_token(SLASHASSIGN);
        break;
      case ANDASSIGN:
        assignToken = jj_consume_token(ANDASSIGN);
        break;
      case ORASSIGN:
        assignToken = jj_consume_token(ORASSIGN);
        break;
      case XORASSIGN:
        assignToken = jj_consume_token(XORASSIGN);
        break;
      case REMASSIGN:
        assignToken = jj_consume_token(REMASSIGN);
        break;
      case LSHIFTASSIGN:
        assignToken = jj_consume_token(LSHIFTASSIGN);
        break;
      case RSIGNEDSHIFTASSIGN:
        assignToken = jj_consume_token(RSIGNEDSHIFTASSIGN);
        break;
      case RUNSIGNEDSHIFTASSIGN:
        assignToken = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
        break;
      default:
        jj_la1[160] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.appendSourceItem(extent(assignToken), assignToken.image);
      assignOperand = Expression(compiler);
      break;
    default:
      jj_la1[161] = jj_gen;
      ;
    }
    if (assignOperand == null)
      {if (true) return param;}
    {if (true) return compiler.getTermFactoryArtifact().expression(param, assignToken.image, assignOperand);}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupDeclaration(Compiler compiler) throws ParseException
 {
  Group group = new Group();
    jj_consume_token(LPAREN);
    Group(group, compiler);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[162] = jj_gen;
        break label_27;
      }
      jj_consume_token(COMMA);
      Group(group, compiler);
    }
    jj_consume_token(RPAREN);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final public void Group(Group group, Compiler compiler) throws ParseException
 {
  Token groupToken;
    groupToken = jj_consume_token(IDENTIFIER);
    compiler.addSourceItem(groupToken.image, unit(groupToken), extent(groupToken));
    compiler.getRegularExpressionArtifact().group(group, groupToken.image);
  }

  final public int RegexFlags(Compiler compiler) throws ParseException
 {
  int flags = 0;
  Token flagToken;
  Token openToken = null;
  Token closeToken = null;
  StringBuilder builder = new StringBuilder();
    openToken = jj_consume_token(LPAREN);
    builder.append(openToken.image);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[163] = jj_gen;
        break label_28;
      }
      flagToken = jj_consume_token(IDENTIFIER);
      builder.append(' ').append(flagToken.image);
      flags |= compiler.getRegularExpressionArtifact().mapRegexFlag(flagToken.image);
    }
    closeToken = jj_consume_token(RPAREN);
    builder.append(' ').append(closeToken.image);
    compiler.addSourceItem(builder.toString(), unit(openToken), extent(closeToken));
    {if (true) return flags;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand ConditionalOrExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = ConditionalAndExpression(compiler);
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[164] = jj_gen;
        break label_29;
      }
      op = jj_consume_token(SC_OR);
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = ConditionalAndExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand ConditionalAndExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = InclusiveOrExpression(compiler);
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[165] = jj_gen;
        break label_30;
      }
      op = jj_consume_token(SC_AND);
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = InclusiveOrExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand InclusiveOrExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = ExclusiveOrExpression(compiler);
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[166] = jj_gen;
        break label_31;
      }
      op = jj_consume_token(BIT_OR);
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = ExclusiveOrExpression(compiler);
       params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand ExclusiveOrExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = AndExpression(compiler);
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[167] = jj_gen;
        break label_32;
      }
      op = jj_consume_token(XOR);
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = AndExpression(compiler);
       params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand AndExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = EqualityExpression(compiler);
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[168] = jj_gen;
        break label_33;
      }
      op = jj_consume_token(BIT_AND);
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = EqualityExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand EqualityExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = RelationalExpression(compiler);
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[169] = jj_gen;
        break label_34;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NE:
        op = jj_consume_token(NE);
        break;
      default:
        jj_la1[170] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = RelationalExpression(compiler);
       params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand RelationalExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = ShiftExpression(compiler);
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GT:
      case LE:
      case GE:
        ;
        break;
      default:
        jj_la1[171] = jj_gen;
        break label_35;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        op = jj_consume_token(LT);
        break;
      case GT:
        op = jj_consume_token(GT);
        break;
      case LE:
        op = jj_consume_token(LE);
        break;
      case GE:
        op = jj_consume_token(GE);
        break;
      default:
        jj_la1[172] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = ShiftExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand ShiftExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = AdditiveExpression(compiler);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case RUNSIGNEDSHIFT:
      case RSIGNEDSHIFT:
        ;
        break;
      default:
        jj_la1[173] = jj_gen;
        break label_36;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        op = jj_consume_token(LSHIFT);
        break;
      case RSIGNEDSHIFT:
        op = jj_consume_token(RSIGNEDSHIFT);
        break;
      case RUNSIGNEDSHIFT:
        op = jj_consume_token(RUNSIGNEDSHIFT);
        break;
      default:
        jj_la1[174] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = AdditiveExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand AdditiveExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = MultiplicativeExpression(compiler);
    label_37:
    while (true) {
      if (jj_2_30(2)) {
        ;
      } else {
        break label_37;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[175] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = MultiplicativeExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand MultiplicativeExpression(Compiler compiler) throws ParseException
 {
  Token op;
  IOperand[] params = new IOperand[2];
    params[0] = UnaryExpression(compiler);
    label_38:
    while (true) {
      if (jj_2_31(2)) {
        ;
      } else {
        break label_38;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        op = jj_consume_token(STAR);
        break;
      case SLASH:
        op = jj_consume_token(SLASH);
        break;
      case REM:
        op = jj_consume_token(REM);
        break;
      default:
        jj_la1[176] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      intercept(op, compiler);
      compiler.appendSourceItem(extent(token), op.image);
      params[1] = UnaryExpression(compiler);
      params[0] = compiler.evaluationExpression(params[0], op.image, params[1]);
    }
    {if (true) return params[0];}
    throw new Error("Missing return statement in function");
  }

  final public IOperand UnaryExpression(Compiler compiler) throws ParseException
 {
  Token unaryToken;
  IOperand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        unaryToken = jj_consume_token(PLUS);
        break;
      case MINUS:
        unaryToken = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[177] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    intercept(unaryToken, compiler);
    compiler.appendSourceItem(extent(token), unaryToken.image);
      param = UnaryExpression(compiler);
    {if (true) return compiler.getExpressionArtifact().unaryExpression(unaryToken.image, param);}
      break;
    case FACT:
    case SCOPE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case INCR:
    case DECR:
    case SLASH:
    case 93:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        param = PreIncrementExpression(compiler);
        break;
      case DECR:
        param = PreDecrementExpression(compiler);
        break;
      case FACT:
      case SCOPE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case SLASH:
      case 93:
        if (jj_2_32(2)) {
          param = UnaryExpressionNotPlusMinus(compiler);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FACT:
            param = FactTerm(compiler);
            break;
          default:
            jj_la1[178] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[179] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    {if (true) return param;}
      break;
    default:
      jj_la1[180] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand PreIncrementExpression(Compiler compiler) throws ParseException
 {
  Token unaryToken;
  Token nameToken;
  IOperand param;
    unaryToken = jj_consume_token(INCR);
    intercept(unaryToken, compiler);
    compiler.appendSourceItem(extent(token), unaryToken.image);
    param = PrimaryExpression(compiler);
     {if (true) return compiler.getExpressionArtifact().unaryExpression("++", param);}
    throw new Error("Missing return statement in function");
  }

  final public IOperand PreDecrementExpression(Compiler compiler) throws ParseException
 {
  Token unaryToken;
  Token nameToken;
  IOperand param;
    unaryToken = jj_consume_token(DECR);
    intercept(unaryToken, compiler);
    compiler.appendSourceItem(extent(token), unaryToken.image);
    param = PrimaryExpression(compiler);
    {if (true) return compiler.getExpressionArtifact().unaryExpression("--", param);}
    throw new Error("Missing return statement in function");
  }

  final public IOperand FactTerm(Compiler compiler) throws ParseException
 {
  Token factToken = null;
  Token nameToken = null;
  Token postfixToken = null;
  QualifiedName qname = null;
  TermArtifact parserTerm = null;
  ListReference listReference = null;
  IOperand operand;
    factToken = jj_consume_token(FACT);
    nameToken = jj_consume_token(IDENTIFIER);
        qname = compiler.name(nameToken.image, true, false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
    case RARROW:
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case RARROW:
        listReference = IndexExpression(compiler);
        break;
      case INCR:
      case DECR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCR:
          postfixToken = jj_consume_token(INCR);
          break;
        case DECR:
          postfixToken = jj_consume_token(DECR);
          break;
        default:
          jj_la1[181] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[182] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          parserTerm = parserTerm = compiler.termArtifactInstance(null, qname, listReference);
      break;
    default:
      jj_la1[183] = jj_gen;
      ;
    }
     compiler.appendSourceItem(extent(token), factToken.image + " " + nameToken.image);
     if (listReference != null) {
       TermArtifact referenceTerm = compiler.termArtifactInstance(parserTerm.getVarSpec(), parserTerm.getQname(), listReference);
       {if (true) return compiler.getTermFactoryArtifact().createFact(referenceTerm);}
     }
     else if (postfixToken != null)
       {if (true) return compiler.getTermFactoryArtifact().createFact(parserTerm, postfixToken.image);}
     else
       {if (true) return compiler.getTermFactoryArtifact().createFact(qname);}
    throw new Error("Missing return statement in function");
  }

  final public IOperand UnaryExpressionNotPlusMinus(Compiler compiler) throws ParseException
 {
  Token unaryToken;
  IOperand param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case 93:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
        unaryToken = jj_consume_token(BANG);
        break;
      case 93:
        unaryToken = jj_consume_token(93);
        break;
      default:
        jj_la1[184] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      intercept(unaryToken, compiler);
      compiler.appendSourceItem(extent(token), unaryToken.image);
      param = UnaryExpression(compiler);
      {if (true) return compiler.getExpressionArtifact().unaryExpression(unaryToken.image, param);}
      break;
    case SCOPE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case SLASH:
      param = PostfixExpression(compiler);
    {if (true) return param;}
      break;
    default:
      jj_la1[185] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand PostfixExpression(Compiler compiler) throws ParseException
 {
  Token paramToken = null;
  Token postfixToken = null;
  IOperand param;
    param = PrimaryExpression(compiler);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
    case DECR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        postfixToken = jj_consume_token(INCR);
        break;
      case DECR:
        postfixToken = jj_consume_token(DECR);
        break;
      default:
        jj_la1[186] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[187] = jj_gen;
      ;
    }
    if (postfixToken != null)
    {
      compiler.appendSourceItem(extent(token), postfixToken.image);
      {if (true) return compiler.getExpressionArtifact().postfixExpression(param, postfixToken.image);}
    } else {
      {if (true) return param;}
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand PrimaryExpression(Compiler compiler) throws ParseException
 {
  Token encloseToken;
  Token scopeToken;
  Token name;
  QualifiedName qname;
  IOperand param1 = null;
  ListReference listReference;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
    case UNKNOWN:
      param1 = Literal(compiler);
    compiler.appendSourceItem(extent(token), param1.toString());
    {if (true) return param1;}
      break;
    case IDENTIFIER:
    case AT:
    case SLASH:
      qname = Name(compiler, true, false);
      if (jj_2_33(2)) {
        param1 = NamedExpression(compiler.getListFactoryArtifact().getListName(qname, currentName), compiler);
      } else {
        ;
      }
    if (param1 != null)
      {if (true) return param1;}
    compiler.appendSourceItem(extent(token), currentName);
    {if (true) return compiler.getExpressionArtifact().primaryExpression(qname);}
      break;
    case LPAREN:
      encloseToken = jj_consume_token(LPAREN);
      intercept(encloseToken, compiler);
      compiler.appendSourceItem(extent(encloseToken), encloseToken.image);
      param1 = Expression(compiler);
      encloseToken = jj_consume_token(RPAREN);
      compiler.appendSourceItem(extent(encloseToken), encloseToken.image);
    compiler.flagEnclosedIfEvaluator(param1);
    {if (true) return param1;}
      break;
    case SCOPE:
      scopeToken = jj_consume_token(SCOPE);
      intercept(scopeToken, compiler);
      compiler.appendSourceItem(extent(token), scopeToken.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case RARROW:
        listReference = IndexExpression(compiler);
        {if (true) return compiler.getScopeArtifact().createScopeParam(listReference);}
        break;
      case DOT:
        jj_consume_token(DOT);
        name = jj_consume_token(IDENTIFIER);
        compiler.appendSourceItem(extent(token), "." + name.image);
        {if (true) return compiler.getFunctionFactoryArtifact().createScopeFunction(QualifiedName.SCOPE, name.image);}
        break;
      default:
        jj_la1[188] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[189] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand Literal(Compiler compiler) throws ParseException
 {
  Token lit;
  boolean flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      lit = jj_consume_token(INTEGER_LITERAL);
     intercept(lit, compiler);
     {if (true) return compiler.getLiteralArtifact().literal(Long.decode(lit.image));}
      break;
    case FLOATING_POINT_LITERAL:
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
    intercept(lit, compiler);
    {if (true) return compiler.getLiteralArtifact().literal(Double.valueOf(lit.image));}
      break;
    case STRING_LITERAL:
      lit = jj_consume_token(STRING_LITERAL);
    intercept(lit, compiler);
    {if (true) return compiler.getLiteralArtifact().literal(String.valueOf(getText(lit)));}
      break;
    case TRUE:
    case FALSE:
      flag = BooleanLiteral(compiler);
    {if (true) return compiler.getLiteralArtifact().literal(flag);}
      break;
    case UNKNOWN:
      UnknownLiteral(compiler);
    {if (true) return compiler.getLiteralArtifact().literal(new Unknown());}
      break;
    default:
      jj_la1[190] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IOperand LiteralSet(Compiler compiler) throws ParseException
 {
  Token braceToken;
  List<Parameter> literalList = null;
    braceToken = jj_consume_token(LBRACE);
    literalList = LiteralList(compiler);
    braceToken = jj_consume_token(RBRACE);
    StringBuilder builder = new StringBuilder(" ");
    builder.append('{');
    for (Parameter item: literalList)
      builder.append(display(item.getValue()));
    builder.append('}');
    compiler.appendSourceItem(extent(braceToken), builder.toString());
    {if (true) return compiler.getLiteralArtifact().literalSet(literalList);}
    throw new Error("Missing return statement in function");
  }

  final public IOperand NamedExpression(QualifiedName qname, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  IOperand operand;
  ListReference listReference;
  compiler.appendSourceItem(extent(token), currentName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
    case RARROW:
      listReference = IndexExpression(compiler);
        operand = compiler.getListFactoryArtifact().listReference(qname, listReference);
      break;
    case LPAREN:
      operand = FunctionCall(compiler.functionArtifactInstance(qname, currentName), compiler);
      break;
    default:
      jj_la1[191] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public IOperand FunctionCall(FunctionArtifact parserFunction, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token quoteToken = null;
  ITemplate parameterTemplate = null;
  ListReference listReference = null;
  IOperand expression;
  SourceItem sourceItem;
  ChoiceArtifact choiceSpec;
  IOperand operand;
  ITemplate receiver = null;
  TemplateArtifact parserTemplate = null;
    itemToken = jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
    case TERM:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case QUOTE:
    case TRUE:
    case FALSE:
    case UNKNOWN:
    case IDENTIFIER:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIST:
      case TERM:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case UNKNOWN:
      case IDENTIFIER:
      case MINUS:
        parameterTemplate = Parameters(currentName, compiler, true);
        parserFunction.setParametersTemplate(parameterTemplate);
        break;
      case QUOTE:
        quoteToken = jj_consume_token(QUOTE);
         parserFunction.setQuote(quoteToken.image);
        break;
      default:
        jj_la1[192] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[193] = jj_gen;
      ;
    }
    delimitToken = jj_consume_token(RPAREN);
      if (parameterTemplate != null)
        compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      else
        compiler.appendSourceItem(extent(delimitToken), itemToken.image + delimitToken.image);
      operand = compiler.getFunctionFactoryArtifact().createCallOperand(parserFunction);
    if (jj_2_34(2)) {
      delimitToken = jj_consume_token(LBRACE);
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
      Receiver(parserFunction, compiler);
      delimitToken = jj_consume_token(RBRACE);
      compiler.appendSourceItem(extent(delimitToken), delimitToken.image);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
    case RARROW:
      listReference = IndexExpression(compiler);
      operand = compiler.getFunctionFactoryArtifact().setListReference(operand, listReference);
      break;
    default:
      jj_la1[194] = jj_gen;
      ;
    }
    {if (true) return operand;}
    throw new Error("Missing return statement in function");
  }

  final public void Receiver(FunctionArtifact parserFunction, Compiler compiler) throws ParseException
 {
  Token delimitToken;
  Token privateToken = null;
  IOperand operand;
  ITemplate template = compiler.getFunctionFactoryArtifact().createReceiverTemplate(parserFunction.getName(), parserFunction);
  parserFunction.setReceiver(template);
  TemplateArtifact parserTemplate = compiler.templateArtifactInstance(template);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      privateToken = jj_consume_token(DOT);
      break;
    default:
      jj_la1[195] = jj_gen;
      ;
    }
    operand = Flow(parserTemplate, compiler);
      if (privateToken != null) {
        operand.setPrivate(true);
        privateToken = null;
      }
      template.addTerm(operand);
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[196] = jj_gen;
        break label_39;
      }
      delimitToken = jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        privateToken = jj_consume_token(DOT);
        break;
      default:
        jj_la1[197] = jj_gen;
        ;
      }
      operand = Flow(parserTemplate, compiler);
        if (privateToken != null) {
          operand.setPrivate(true);
          privateToken = null;
        }
        template.addTerm(operand);
    }
    compiler.getFunctionFactoryArtifact().popReceiver(parserFunction);
    parserTemplate.adjustContextName();
  }

  final public ListReference IndexExpression(Compiler compiler) throws ParseException
 {
  DualIndex index1;
  DualIndex index2 = null;
    index1 = ListSelection(compiler);
    if (jj_2_35(2)) {
      index2 = ListSelection(compiler);
    } else {
      ;
    }
     if (index2 == null)
       {if (true) return new ListReference(index1);}
     else
       {if (true) return new ListReference(index1, index2);}
    throw new Error("Missing return statement in function");
  }

  final public DualIndex ListSelection(Compiler compiler) throws ParseException
 {
  Token name;
  Token lbracket;
  Token rbracket;
  Token rarrow;
  IOperand param;
  ExpressionIndex expressionIndex = null;
  NameIndex nameIndex = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      lbracket = jj_consume_token(LBRACKET);
      compiler.appendSourceItem(extent(lbracket), lbracket.image);
      param = Expression(compiler);
      rbracket = jj_consume_token(RBRACKET);
      compiler.appendSourceItem(extent(rbracket), rbracket.image);
      expressionIndex = compiler.expressionIndexInstance(param);
      break;
    case RARROW:
      rarrow = jj_consume_token(RARROW);
      name = jj_consume_token(IDENTIFIER);
      compiler.appendSourceItem(extent(token), rarrow.image + name.image);
      nameIndex = new NameIndex(rarrow.image, name.image);
      break;
    default:
      jj_la1[198] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (expressionIndex != null)
      {if (true) return new DualIndex(expressionIndex);}
    else
      {if (true) return new DualIndex(nameIndex);}
    throw new Error("Missing return statement in function");
  }

  final public void ScopeDeclaration(Compiler compiler) throws ParseException
 {
  Token scopeToken;
  Token nameToken;
  InitialProperties properties = new InitialProperties();
  if (currentNonTerminal.equals(SourceTracker.INPUT)) {
    currentNonTerminal = "ScopeDeclaratioo";
    compiler.setSourceMarker(currentNonTerminal);
  }
    scopeToken = jj_consume_token(SCOPE);
    nameToken = jj_consume_token(IDENTIFIER);
    compiler.addSourceItem(scopeToken + " " + nameToken.image, unit(scopeToken), extent(nameToken));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      InitialiserList(properties, compiler);
      break;
    default:
      jj_la1[199] = jj_gen;
      ;
    }
    compiler.getScopeArtifact().createScope(nameToken.image, properties);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AXIOM:
        case BOOLEAN:
        case COMPLEX:
        case CURRENCY:
        case DECIMAL:
        case DOUBLE:
        case EXPORT:
        case FLOW:
        case FUNCTION:
        case INCLUDE:
        case INTEGER:
        case LIST:
        case QUERY:
        case SELECT:
        case STRING:
        case TEMPLATE:
        case TERM:
        case IDENTIFIER:
        case AT:
        case SLASH:
          ;
          break;
        default:
          jj_la1[200] = jj_gen;
          break label_40;
        }
        if (jj_2_36(2)) {
          Statement(compiler);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case QUERY:
            QueryChain(compiler);
            break;
          case FUNCTION:
            FunctionDeclaration(compiler);
            break;
          default:
            jj_la1[201] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[202] = jj_gen;
      ;
    }
    compiler.getScopeArtifact().resetScope();
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_3R_176() {
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(QMARK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    xsp = jj_scanpos;
    if (jj_3R_171()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_scan_token(CURSOR)) return true;
    xsp = jj_scanpos;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    }
    return false;
  }

  private boolean jj_3R_227() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) return true;
    }
    }
    }
    if (jj_3R_226()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    }
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_3R_226()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_227()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_scan_token(QMARK)) return true;
    if (jj_scan_token(QMARK)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_223() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) return true;
    }
    if (jj_3R_222()) return true;
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_3R_222()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_223()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(AXIOM)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(41)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(LIST)) return true;
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_218()) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_3R_218()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_219()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_scan_token(AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) return true;
    }
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(CURRENCY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(SCOPE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) return true;
    }
    return false;
  }

  private boolean jj_3_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_211()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_scan_token(8)) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_3R_211()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_212()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_46()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(19)) jj_scanpos = xsp;
    if (jj_scan_token(MAP)) return true;
    xsp = jj_scanpos;
    if (jj_3R_142()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(AT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_3R_65()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_195()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_scan_token(RARROW)) return true;
    return false;
  }

  private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) jj_scanpos = xsp;
    if (jj_scan_token(AXIOM)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(19)) jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_3R_195()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_196()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_188() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(QMARK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) return true;
    }
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_3R_65()) return true;
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_194() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_139()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(AXIOM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_140()) jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_161()) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_3R_161()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_162()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_189() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_3R_188()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_189()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(TERM)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(TERM)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(TERM)) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_124()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_125()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_156() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(SELECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(92)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    }
    return false;
  }

  private boolean jj_3R_110() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) return true;
    }
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_3R_198()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_77()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(FLOW)) return true;
    if (jj_3R_194()) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_183()) return true;
    return false;
  }

  private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) jj_scanpos = xsp;
    if (jj_scan_token(AXIOM)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_235() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(PLUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_225() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_217() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    return false;
  }

  private boolean jj_3R_233() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) return true;
    }
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(TEMPLATE)) return true;
    if (jj_3R_194()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_131() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(FACT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_233()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_65()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(RARROW)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) return true;
    }
    return false;
  }

  private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    xsp = jj_scanpos;
    if (jj_3R_130()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(19)) jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_78()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) return true;
    }
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_61()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_62()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(INCLUDE)) return true;
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_3R_203()) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_151() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) return true;
    }
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_3R_114()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_200()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_3R_186()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    }
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    return false;
  }

  private boolean jj_3R_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) return true;
    }
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_127()) return true;
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_143() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) return true;
    }
    return false;
  }

  private boolean jj_3R_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(50)) jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_3R_217()) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_scan_token(LIST)) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_224()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) return true;
    }
    }
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(91)) return true;
    if (jj_scan_token(LIST)) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(FLOW)) return true;
    if (jj_3R_65()) return true;
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_3R_68()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_31()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(EXPORT)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_scan_token(QMARK)) return true;
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_164() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) jj_scanpos = xsp;
    if (jj_scan_token(LIST)) return true;
    xsp = jj_scanpos;
    if (jj_3R_81()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_scan_token(NAN)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_3R_184()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_128() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_3R_183()) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_scan_token(QMARK)) return true;
    if (jj_scan_token(QMARK)) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_scan_token(QUOTE)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) return true;
    }
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_3R_217()) return true;
    return false;
  }

  private boolean jj_3R_190() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    }
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_30()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) return true;
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(REMASSIGN)) return true;
    if (jj_scan_token(LSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_190()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) return true;
    }
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_scan_token(92)) return true;
    return false;
  }

  private boolean jj_3R_232() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) return true;
    }
    }
    if (jj_3R_231()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_231()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_232()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_17() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_70() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    }
    return false;
  }

  /** Generated Token Manager. */
  public TaqParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[203];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x3eeebbc0,0x3eeebbc0,0x20000040,0x0,0x8041b80,0x0,0x0,0x0,0x0,0x10080040,0x0,0x10080040,0x0,0x0,0x3c0ebbc0,0x82000,0x20000040,0x0,0x0,0x80c1ac0,0x80c1ac0,0x0,0x8041a80,0x0,0x28041a80,0x0,0x0,0x28041a80,0x0,0x0,0x80000,0x0,0x28041b80,0x800,0x42004800,0x4000,0x4000,0x2000,0x80000,0x800,0x80040,0x0,0x1000000,0x0,0x0,0x0,0x2000,0x0,0x0,0x80000,0x1000000,0x1080000,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2d043fc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4a0c5b80,0x4a045b80,0x80000,0x0,0x4a045b80,0x80000,0x0,0x60080000,0x0,0x60080000,0x3080440,0x0,0x0,0x42000000,0x42004000,0x42004000,0x0,0x0,0x0,0x0,0x6b0cdfc0,0x8000,0x0,0x0,0x8041b80,0x0,0x0,0x8041b80,0x4a1c5bc0,0x0,0x0,0x28041b80,0x0,0x80000,0x2000000,0x0,0x20000000,0x0,0x0,0x20000000,0x0,0x0,0x0,0x20000000,0x0,0x60080000,0x0,0x0,0x0,0x0,0x4a045b80,0x0,0x0,0x60000000,0x0,0x0,0x8041b80,0x28041bc0,0x0,0x0,0x0,0x0,0x0,0x480c1b80,0x480c1b80,0x0,0x0,0x48041b80,0x48041b80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x42004000,0x42004000,0x0,0x0,0x0,0x0,0x42000000,0x0,0x0,0x0,0x42000000,0x40000000,0x0,0x60080000,0x60080000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c4fbbc0,0x410000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x100200,0x100200,0x0,0x20000,0x0,0x4000400,0x4000400,0x8,0x80000,0x0,0x80000,0x0,0x400,0x400,0x100200,0x0,0x0,0x800000,0x80000,0x80,0x80,0x400,0x0,0x20000,0x0,0x8000000,0x8000000,0x0,0x20000,0x400,0x0,0x208,0x0,0x100200,0x21016ea,0x400000,0x400000,0x0,0x0,0x100200,0x0,0x400000,0x0,0x400,0x800200,0x400000,0x0,0x800000,0x4000,0x100200,0x0,0x101200,0x400,0x401400,0x401400,0x0,0x800000,0x400,0x20000,0x400,0x8000000,0x800000,0x20000,0x1000,0x0,0x40000,0x20000,0x40000,0x40000,0x20000,0x40000,0x400,0x1000,0x21006ea,0x21006ea,0x0,0x20000,0x21006ea,0x0,0x20000,0x2ea,0x20000,0x2ea,0x0,0x200,0xf9800000,0x1006ea,0xfb9016ea,0x21006ea,0x400,0x0,0x1000,0x8000000,0xa1016ea,0x8001200,0x0,0x20000,0x0,0x84000,0x400000,0x0,0x21006ea,0x400,0x400400,0x100200,0x200,0x0,0x0,0x8000000,0x200,0x84000,0x400000,0x200,0x20000,0x84000,0x400000,0x200,0x0,0x2ea,0x20000,0x20000,0x100200,0x0,0x21006ea,0x484000,0x484000,0x2ea,0x40000,0x208,0x0,0x0,0x400,0x1000,0x0,0x20000,0x0,0x2ea,0x80003ea,0x400,0x20000,0x1002ea,0xea,0x20000,0x200,0x20000,0x100200,0x140000,0x200,0x140000,0x100000,0x40000,0x40000,0x140000,0x20000,0x0,0x0,0xea,0x60,0x400000,0x400000,0x20000,0x200,0x0,0x0,0x0,0x0,0x0,0x90000000,0x90000000,0x61800000,0x61800000,0x0,0x0,0x0,0x0,0x0,0x0,0x21006ea,0x21006ea,0x0,0x84000,0x84000,0x2000000,0x21006ea,0x0,0x0,0xc4000,0x1006ea,0xea,0x84400,0x2fa,0x2fa,0x84000,0x40000,0x20000,0x40000,0x84000,0x400,0x100200,0x0,0x1000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x8000000,0x8000000,0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x200000bc,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000bc,0x200000bc,0x0,0x0,0x200000bc,0x0,0x0,0x20,0x0,0x20,0x0,0x0,0x0,0x80,0x200000bc,0x200000bc,0x0,0x10000000,0x0,0x0,0x200000bc,0x0,0xc,0x0,0x0,0x0,0x8000,0x0,0x200000bc,0x137f0000,0x137f8000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x37f0000,0x20,0x0,0x0,0x80,0xc,0x200000bc,0xc,0xc,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x200,0x20,0x20,0x0,0x0,0xa0,0x20,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x20,0x0,0x3ff8000,0x3ff8000,0x0,0x0,0x1,0x2,0x200,0x400,0x100,0x0,0x0,0x0,0x0,0x7000,0x7000,0x30,0x8c0,0x30,0x0,0x2000008c,0x200000bc,0xc,0xc,0xc,0x20000000,0x20000080,0xc,0xc,0x0,0x80,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[36];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public TaqParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TaqParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TaqParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 203; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 203; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public TaqParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TaqParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 203; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 203; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public TaqParser(TaqParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 203; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TaqParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 203; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[94];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 203; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 94; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 36; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

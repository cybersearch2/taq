/** Copyright 2022 Andrew J Bowley

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. */
package au.com.cybersearch2.taq.compiler;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import au.com.cybersearch2.taq.QueryProgram;
import au.com.cybersearch2.taq.Scope;
import au.com.cybersearch2.taq.artifact.ArchetypeArtifact;
import au.com.cybersearch2.taq.artifact.AxiomArtifact;
import au.com.cybersearch2.taq.artifact.ChoiceArtifact;
import au.com.cybersearch2.taq.artifact.ChoiceFactoryArtifact;
import au.com.cybersearch2.taq.artifact.ComplexArtifact;
import au.com.cybersearch2.taq.artifact.CursorArtifact;
import au.com.cybersearch2.taq.artifact.ExpressionArtifact;
import au.com.cybersearch2.taq.artifact.FunctionArtifact;
import au.com.cybersearch2.taq.artifact.FunctionFactoryArtifact;
import au.com.cybersearch2.taq.artifact.ListArtifact;
import au.com.cybersearch2.taq.artifact.ListFactoryArtifact;
import au.com.cybersearch2.taq.artifact.LiteralArtifact;
import au.com.cybersearch2.taq.artifact.QueryArtifact;
import au.com.cybersearch2.taq.artifact.RegularExpressionArtifact;
import au.com.cybersearch2.taq.artifact.ResourceArtifact;
import au.com.cybersearch2.taq.artifact.ScopeArtifact;
import au.com.cybersearch2.taq.artifact.TemplateArtifact;
import au.com.cybersearch2.taq.artifact.TermArtifact;
import au.com.cybersearch2.taq.artifact.TermFactoryArtifact;
import au.com.cybersearch2.taq.artifact.VariableArtifact;
import au.com.cybersearch2.taq.compile.OperandMap;
import au.com.cybersearch2.taq.compile.ParserAssembler;
import au.com.cybersearch2.taq.compile.ParserContext;
import au.com.cybersearch2.taq.compile.ParserTask;
import au.com.cybersearch2.taq.engine.Extent;
import au.com.cybersearch2.taq.engine.Parser;
import au.com.cybersearch2.taq.engine.SourceItem;
import au.com.cybersearch2.taq.engine.SourceMarker;
import au.com.cybersearch2.taq.engine.SourceTracker;
import au.com.cybersearch2.taq.engine.Unit;
import au.com.cybersearch2.taq.expression.Evaluator;
import au.com.cybersearch2.taq.expression.ListOperand;
import au.com.cybersearch2.taq.expression.TemplateOperand;
import au.com.cybersearch2.taq.interfaces.Operand;
import au.com.cybersearch2.taq.language.DualIndex;
import au.com.cybersearch2.taq.language.ExpressionIndex;
import au.com.cybersearch2.taq.language.IOperand;
import au.com.cybersearch2.taq.language.ITemplate;
import au.com.cybersearch2.taq.language.IVariableSpec;
import au.com.cybersearch2.taq.language.ListReference;
import au.com.cybersearch2.taq.language.OperandType;
import au.com.cybersearch2.taq.language.QualifiedName;
import au.com.cybersearch2.taq.language.TaqLiteral;
import au.com.cybersearch2.taq.list.ListLength;

/** 
 * Compiler
 * Creates artifacts from productions of the JavaCC Expression Pattern Language parser. 
 * Provides utilities such as source tracking and handles creation of miscellaneous artifacts
 * while creating the remaining artifacts are delegated to dedicated "Parser" classes.
 * @author Andrew Bowley
 */
public class Compiler implements au.com.cybersearch2.taq.engine.Compiler
{
    /** Interface to the main parser class generated by javacc */
	private final Parser parser;
	/** Parser context */
	private final ParserContext parserContext;
	/** Source information collector used for debugging */
	private final SourceTracker sourceTracker;
	
	private final ParserQuery parserQuery;
	private final ParserScope parserScope;
	private final ParserTermFactory parserTermFactory;
	private final ParserFunctionFactory parserFunctionFactory;
	private final ParserChoiceFactory parserChoiceFactory;
	private final ParserLiteral parserLiteral;
	private final ParserVariable parserVariable;
	private final ParserExpression parserExpression;
	private final ParserAxiom parserAxiom;
	
	private ParserCursor parserCursor;
	private ParserRegex parserRegex;
	private ParserComplex parserComplex;
	private ParserListFactory parserListFactory;

	/**
	 * Construct Compiler object which has no external dependencies
	 * @param parser Interface to the main parser class generated by javacc
	 */
	public Compiler(Parser parser) {
		this(parser, new ParserContext(new QueryProgram()));
	}

	/**
	 * Construct Compiler object using given parser context to provide
	 * required external dependencies
	 * @param parser Interface to the main parser class generated by javacc
	 * @param parserContext Parser context configured to provide external dependencies
	 */
	public Compiler(Parser parser, ParserContext parserContext) {
		this.parser = parser;
	    this.parserContext = parserContext;
		String sourceDocument = parserContext.getSourceDocument();
	    sourceTracker = new SourceTracker(sourceDocument);
	    parserQuery = new ParserQuery(parserContext);
	    parserLiteral = new ParserLiteral(parserContext);
	    parserVariable = new ParserVariable(parserContext);
	    parserExpression = new ParserExpression(parserContext);
	    parserAxiom = new ParserAxiom(parserContext);
	    parserTermFactory = new ParserTermFactory(parserContext);
	    parserFunctionFactory = new ParserFunctionFactory(parserContext);
	    parserChoiceFactory = new ParserChoiceFactory(parserContext);
		parserListFactory = new ParserListFactory(parserContext);
		parserScope = new ParserScope(parserContext,parserListFactory);
	}

	/**
	 * Input current document of parser
	 */
	public void compile() {
		parser.parse(this);
	}

    /** 
     * Returns compiled result of TAQ script from supplied input stream.
     * @param inputStream  InputStream
     * @return QueryProgram object
     * @throws CompilerException if TAQ compile failed
     */
    public QueryProgram parse(InputStream inputStream) throws CompilerException
    {
		parser.reinitialize(inputStream);
	    QueryProgram queryProgram = new QueryProgram();
	    Compiler nestedCompiler = new Compiler(parser);
	    nestedCompiler.compile();
	    return queryProgram;
    }
    
	public QueryArtifact getQueryArtifact() {
		return parserQuery;
	}

	public ScopeArtifact getScopeArtifact() {
		return parserScope;
	}
	
	public TermFactoryArtifact getTermFactoryArtifact() {
		return parserTermFactory;
	}

	public FunctionFactoryArtifact getFunctionFactoryArtifact() {
		return parserFunctionFactory;
	}

	public ChoiceFactoryArtifact getChoiceFactoryArtifact() {
		return parserChoiceFactory;
	}

	public LiteralArtifact getLiteralArtifact() {
		return parserLiteral;
	}

	public VariableArtifact getVariableArtifact() {
		return parserVariable;
	}
	
	public ExpressionArtifact getExpressionArtifact() {
		return parserExpression;
	}

	public AxiomArtifact getAxiomInterface() {
		return parserAxiom;
	}

	public ListFactoryArtifact getListFactoryArtifact() {
		return parserListFactory;
	}
	
	public ParserListFactory getListFactory() {
		return parserListFactory;
	}
	
	public CursorArtifact getCursorArtifact() {
    	if (parserCursor == null)
    		parserCursor = new ParserCursor(parserContext);
    	return parserCursor;
	}

	public RegularExpressionArtifact getRegularExpressionArtifact() {
		if (parserRegex == null)
			parserRegex = new ParserRegex(parserContext);
		return parserRegex;
	}
	
	public ComplexArtifact getComplexArtifact() {
		if (parserComplex == null)
		    parserComplex = new ParserComplex(parserContext);
		return parserComplex;
	}

	/**
	 * Returns parser context
	 * @return ParserContext object
	 */
	public ParserContext getParserContext() {
		return parserContext;
	}

	/**
	 * Returns parser assembler
	 * @return ParserAssembler object
	 */
	public ParserAssembler getParserAssembler() {
		return parserContext.getParserAssembler();
	}

	/**
	 * Returns operand Map
	 * @return OPerandMap object
	 */
	public OperandMap getOperandMap() {
		return parserContext.getParserAssembler().getOperandMap();
	}

	/**
	 * Returns object which collects source information for debugging
	 * @return SourceTracker object
	 */
	public SourceTracker getSourceTracker() {
		return sourceTracker;
	}

    /**
     * Push current source marker on a stack and replace it 
     * without adding to list of source markers
     * @param nonTerminal Name of next parser non-terminal
     * @return SourceMarker object of next parser non-terminal
     */
    public SourceMarker pushSourceMarker(String nonTerminal) {
    	return sourceTracker.pushSourceMarker(nonTerminal);
    }
 
    /**
     * Pop source marker off stack and link to tail of previous source item
     * @return SourceMarker object popped off stack
     */
    public SourceMarker popSourceMarker() {
    	return sourceTracker.popSourceMarker();
    }

    /**
     * Add SourceItem object to current source marker
     * @param information Text information
     * @param unit Unit
     * @param extent extent Extent
     * @return SourceItem object
     */
	public SourceItem addSourceItem(String information, Unit unit, Extent extent) {
		return sourceTracker.addSourceItem(information, unit, extent);
	}

    /**
     * Append to current source item given extent and information to append
     * @param extent Extent
     * @param information Variable text parameters
     */
    public void appendSourceItem(Extent extent, String... information)
    {
    	sourceTracker.appendSourceItem(extent, information);
    }
    
    /**
     * Add SourceItem object for an operand to current source marker
     * @param var Operand
     * @param unit Unit
     * @param extent Extent
     * @return SourceItem object
     */
	public SourceItem addSourceVariable(IOperand var, Unit unit, Extent extent) {
		return sourceTracker.addSourceVariable((Operand)var, unit, extent);
	}
	
    /**
     * Create source marker for given non-terminal for case start token is pending.
     * @param nonTerminal Name of parser non-terminal
     * @return SourceMarker object
     */
    public SourceMarker setSourceMarker(String nonTerminal) {
    	return sourceTracker.setSourceMarker(nonTerminal);
    }

	public OperandType getOperandType(TaqLiteral literal) {
    	switch (literal)
    	{
    	case taq_boolean: return OperandType.BOOLEAN;
    	case currency: return OperandType.CURRENCY;
    	case decimal: return OperandType.DECIMAL; 
    	case taq_double: return OperandType.DOUBLE;
    	case integer: return OperandType.INTEGER;
    	case string: return OperandType.STRING;
    	default: // unknown
    		return OperandType.UNKNOWN;
    	}
	}
	
	public String type(OperandType operandType) {
    	switch (operandType)
    	{
    	case BOOLEAN: return "boolean";
    	case CURRENCY: return "currency"; 
    	case DECIMAL: return "decimal"; 
    	case DOUBLE: return "double";
    	case INTEGER: return "integer"; 
    	case STRING: return "string"; 
    	case AXIOM: return "axiom";
    	case TERM: return "term";
    	default: // unknown
    		return "unknown";
    	}
	}
	
	// Parser non-terminals
 
	/**
	 * Process Name production
	 * @param name Identifier
	 * @param isContextName Flag set true to incorporate context details
	 * @param isDelaration Is part of a declaration
	 * @return QualifiedName object
	 */
	public QualifiedName name(String name, boolean isContextName, boolean isDeclaration) {
	    return getParserAssembler().name(name, isContextName, isDeclaration);
	}

	/**
	 * Process AxiomName production.
	 * The given axiom name is canonicalized if constructed from a multi-part string.
	 * @param axiomName Qualified name
	 * @return QualifiedName object
	 */
	public QualifiedName axiomName(QualifiedName axiomName) {
	    String source = axiomName.getSource();
	    return source.indexOf(".") == -1 ? 
	       axiomName : QualifiedName.parseName(source); 
	}

    /**
     * Include TAQ script from named resource
     * @param resourceName Name of file or other resource to include
     * @throws CompilerException if an I/O error occurs
     */
    public void includeResource(String resourceName) throws CompilerException {
	    if (resourceName.length() < 3)
	        throw new CompilerException("Include resourceName \"" + resourceName + "\" is invalid");
		File resourceBase = parserContext.getQueryProgram().getResourceBase();
	    ResourceCompiler resourceCompiler = new ResourceCompiler(parser, sourceTracker, resourceBase);
	    try
	    {
	        resourceCompiler.includeResource(resourceName, parserContext);
	    }
	    catch (IOException e)
	    {
	        throw new CompilerException(e.getMessage());
	    }
    } 

    /**
     * Process binary production, of which there are many, differing only by operator
     * @param left Left hand expression
     * @param operator Binary operator symbol
     * @param right Right hand expression
     * @return Operand object
     */
    public Operand evaluationExpression(IOperand left, String operator, IOperand right) {
        return new Evaluator((Operand)left, operator, (Operand)right);
    }

    /**
     * Returns variable specification of context list of given name
     * @return VariableSpec object or null if there is no context list of that name
     */
    public IVariableSpec getContextListSpec(String name) {
    	return parserContext.getVariableSpec(name);
    }

    /**
     * Returns operand to create an axiom term
     * @param name Term name
     * @param expression Optional expression to set the term value
     * @param listReference Optional list item reference
     * @return Operand object
     */
    @Override
    public Operand termExpression(String name, IOperand expression, ListReference listReference) {
	    QualifiedName qname;
	    if (name.isEmpty())
	    	qname = QualifiedName.ANONYMOUS;
	    else
	    	qname = getParserAssembler().name(name, true, false);
        ParserTerm parserTerm = new ParserTerm(this, null, qname, listReference);
        return parserTermFactory.termExpression(parserTerm, (Operand)expression);
    }

    /**
     * Process InnerFlow production
     * @param template Inner template
     * @param runOnce Flag set true if branch, otherwise is loop
     * @return Operand object
     */
    public Operand innerFlow(ITemplate template, boolean runOnce) {
        return  new TemplateOperand(template, runOnce);
    }

    /**
     * Returns template chained to current template in context
     * @return Template object
     */
	public ITemplate chainTemplate() {
		QualifiedName outerTemplateName = parserContext.getTemplateName();
		ITemplate template = 
		    getParserAssembler().getTemplateAssembler()
		        .chainTemplate(outerTemplateName);
		return template;
	}

	/**
	 * Returns list length operand
	 * @param listName Name of referenced list
	 * @return Operand object
	 */
	public Operand createListLength(QualifiedName listName) {
		QualifiedName qname = new QualifiedName(listName.getName() + "_length", listName);
		ParserAssembler parserAssembler =  getParserAssembler();
		Operand operand = parserAssembler.getOperandMap().get(listName);
		ListLength listLength;
		if (operand instanceof ListOperand)
	        listLength = new ListLength(qname, (ListOperand<?>)operand);
		else {
			if (parserContext.getVariableSpec(listName.getName()) != null)
				listLength = new ListLength(qname, new QualifiedName(Scope.SCOPE, QualifiedName.EMPTY, listName.getName()));
			else
	            listLength = new ListLength(qname, listName);
	        ParserTask parserTask = parserAssembler.addPending(listLength);
	        parserTask.setPriority(ParserTask.Priority.variable.ordinal());
		}
	    return listLength;
	}

    /**
     * Run all parser tasks, which completes compilation after entire program has been input
     */
    public void runPending() {
	    getQueryProgram().runPending();
    }

	/**
	 * Returns key to identify a function
	 * @param callName Name of function
	 * @return key
	 */
	public String functionKey(String callName) {
		QualifiedName outerTemplateName = parserContext.getTemplateName();
		return outerTemplateName.getTemplate() + "." + callName;
	}

	public boolean flagEnclosedIfEvaluator(IOperand operand) {
		if (operand instanceof Evaluator) {
		    ((Evaluator)operand).setEnclosed();
		    return true;
		}
		return false;
	}

	public ExpressionIndex expressionIndexInstance(IOperand expression) {
		return new ExpressionIndex(expression);
	}
	
	public ListReference listReferenceInstance(DualIndex listItemSpec1) {
		return new ListReference(listItemSpec1);
	}
	
	public ListReference listReferenceInstance(DualIndex listItemSpec1, DualIndex listItemSpec2) {
		return new ListReference(listItemSpec1, listItemSpec2);
	}

	public TemplateArtifact templateArtifactInstance(ITemplate template) {
		return new ParserTemplate(this, template);
	}
	
	public TemplateArtifact templateArtifactInstance(String name, boolean isCalculator, boolean returnsTerm) {
		return new ParserTemplate(this, name, isCalculator, returnsTerm);
	}

	public ParserNestedFlow nestedFlowInstance(TemplateArtifact outerTemplate, boolean runOnce) {
		return new ParserNestedFlow(this, outerTemplate, runOnce);
	}

	public ArchetypeArtifact archetypeArtifactInstance(String name, boolean isList) {
		return new ParserArchetype(name, isList, this);
	}

	public ResourceArtifact resourceArtifactInstance(String name) {
		return new ParserResource(this, name);
	}
	
	public FunctionArtifact functionArtifactInstance(QualifiedName qname, String sourceName) {
		return new ParserFunction(qname, sourceName);
	}

	public ChoiceArtifact choiceArtifactInstance(String choiceName, boolean isMap) {
		return new ParserChoice(this, choiceName, isMap);
	}

	public ListArtifact listArtifactInstance(String listName, IVariableSpec varSpec, boolean isExport) {
		return new ParserList(this, listName, varSpec, isExport);
	}
	
	public TermArtifact termArtifactInstance(IVariableSpec varSpec, QualifiedName qname, ListReference listReference) {
		return new ParserTerm(this, varSpec, qname, listReference);
	}
	
	@Override
	public String getScopeName() {
		return parserContext.getScope().getName();
	}
	
   /**
     * Returns Query Program
     * @return QueryProgram object
     */
    QueryProgram getQueryProgram() {
	    return parserContext.getQueryProgram();
    }


}
